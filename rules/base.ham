#
# /+\
#  +\    Copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
# \+/
#
# This file is part of Jam - see jam.c for Copyright information.
#

## PIERRE ##
#
# This is now _base.ham, included in the built-in Jambase so that we
# don't have to rebuild ham everytime we change _base.ham which can
# happen frequently when porting to new platforms.
#
# Added :/ & :\ to variables that converts \ and / characters to the
# platform's path separator
#
# Added HDROPENED which is set by headers1 before parsing a header
# file.  To be used in the HdrRule
#
# DEPHDRS which is a list of directories which are used ONLY by
# HDRSEARCH in the default HdrRule
#
# Added Erlang compilation support, .erl files to .beam with variables :
# SUFBEAM
# ERLC
#

# ERLFLAGS
# ERLOPTIM
# ERLHDRS
# ERLPATH
# ERLDEFS
# ERLSHELL
# ERLSHELLW
#

#
# JAMBASE - jam 2.5 ruleset providing make(1)-like functionality
#
# Supports UNIX, NT, and VMS.
#
# 12/27/93 (seiwald) - purturb library sources with SOURCE_GRIST
# 04/18/94 (seiwald) - use '?=' when setting OS specific vars
# 04/21/94 (seiwald) - do RmTemps together
# 05/05/94 (seiwald) - all supported C compilers support -o: relegate
#              RELOCATE as an option; set Ranlib to "" to disable it
# 06/01/94 (seiwald) - new 'actions existing' to do existing sources
# 08/25/94 (seiwald) - new ObjectCcFlags rule to append to per-target CCFLAGS
# 08/29/94 (seiwald) - new ObjectHdrs rule to append to per-target HDRS
# 09/19/94 (seiwald) - LinkLibraries and Undefs now append
#            - Rule names downshifted.
# 10/06/94 (seiwald) - Dumb yyacc stuff moved into Jamfile.
# 10/14/94 (seiwald) - (Crude) support for .s, .C, .cc, .cpp, and .f files.
# 01/08/95 (seiwald) - Shell now handled with awk, not sed
# 01/10/95 (seiwald) - All entries sorted.
# 01/10/95 (seiwald) - NT support moved in, with LauraW's help.
# 01/10/95 (seiwald) - VMS support moved in.
# 02/06/95 (seiwald) - ObjectC++Flags and SubDirC++Flags added.
# 02/07/95 (seiwald) - Iron out when HDRSEARCH uses "" or SEARCH_SOURCE.
# 02/08/95 (seiwald) - SubDir works on VMS.
# 02/14/95 (seiwald) - MkDir and entourage.
# 04/30/95 (seiwald) - Use install -c flag so that it copies, not moves.
# 07/10/95 (taylor) - Support for Microsoft C++.
# 11/21/96 (peterk) - Support for BeOS
# 07/19/99 (sickel) - Support for Mac OS X Server (and maybe client)
# 02/18/00 (belmonte)- Support for Cygwin.

# Special targets defined in this file:
#
# all       - parent of first, shell, files, lib, exe
# first     - first dependent of 'all', for potential initialization
# shell     - parent of all Shell targets
# files     - parent of all File targets
# lib       - parent of all Library targets
# exe       - parent of all Main targets
# dirs      - parent of all MkDir targets
# clean     - removes all Shell, File, Library, and Main targets
#

# Rules defined by this file:
#
# as obj.o : source.s ;         .s -> .o
# Bulk dir : files ;            populate directory with many files
# Cc obj.o : source.c ;         .c -> .o
# C++ obj.o : source.cc ;       .cc -> .o
# Clean clean : sources ;       remove sources with 'jam clean'
# File dest : source ;          copy file
# Fortran obj.o : source.f ;        .f -> .o
# GenFile source.c : program args ; make custom file
# HardLink target : source ;        make link from source to target
# HdrRule source : headers ;        handle #includes
# Lex source.c : source.l ;     .l -> .c
# Library lib : source ;        archive library from compiled sources
# LibraryFromObjects lib : objects ;    archive library from objects
# LinkLibraries images : libraries ;    bag libraries onto Mains
# Main image : source ;         link executable from compiled sources
# MainFromObjects image : objects ; link executable from objects
# MkDir dir ;               make a directory, if not there
# Object object : source ;      compile object from source
# ObjectCcFlags source : flags ;    add compiler flags for object
# ObjectC++Flags source : flags ;   add compiler flags for object
# ObjectHdrs source : dirs ;        add include directories for object
# Objects sources ;         compile sources
# RmTemps target : sources ;        remove temp sources after target made
# Setuid images ;           mark executables Setuid
# SoftLink target : source ;        make symlink from source to target
# SubDir TOP d1 d2 ... ;        start a subdirectory Jamfile
# SubDirCcFlags flags ;         add compiler flags until next SubDir
# SubDirC++Flags flags ;        add compiler flags until next SubDir
# SubDirHdrs d1 d2 ... ;        add include dir until next SubDir
# SubInclude TOP d1 d2 ... ;        include a subdirectory Jamfile
# Shell exe : source ;          make a shell executable
# Undefines images : symbols ;      save undef's for linking
# UserObject object : source ;      handle unknown suffixes for Object
# Yacc source.c : source.y ;        .y -> .c
#
# Utility rules that have no side effects (not supported):
#
# FAppendSuffix f1 f2 ... : $(SUF) ;    return $(<) with suffixes
# FDirName d1 d2 ... ;          return path from root to dir
# FGrist d1 d2 ... ;            return d1!d2!...
# FGristFiles value ;           return $(value:G=$(SOURCE_GRIST))
# FGristSourceFiles value ;     return $(value:G=$(SOURCE_GRIST))
# FStripCommon v1 : v2 ;        strip common initial parts of v1 v2
# FReverse a1 a2 ... ;          return ... a2 a1
# FRelPath d1 : d2 ;            return rel path from d1 to d2
# FSubDir d1 d2 ... ;           return path to root
#

# Brief review of the jam language:
#
# Statements:
#   rule RULE - statements to process a rule
#   actions RULE - system commands to carry out target update
#
# Modifiers on actions:
#   together - multiple instances of same rule on target get executed
#          once with their sources ($(>)) concatenated
#   updated - refers to updated sources ($(>)) only
#   ignore - ignore return status of command
#   quietly - don't trace its execution unless verbose
#   piecemeal - iterate command each time with a small subset of $(>)
#   existing - refers to currently existing sources ($(>)) only
#   bind vars - subject to binding before expanding in actions
#
# Special rules:
#   Always - always build a target
#   Depends - builds the dependency graph
#   Echo - blurt out targets on stdout
#   Exit - blurt out targets and exit
#   Includes - marks sources as headers for target (a codependency)
#   NoCare - don't panic if the target can't be built
#   NoUpdate - create the target if needed but never update it
#   NotFile - ignore the timestamp of the target (it's not a file)
#   Temporary - target need not be present if sources haven't changed
#
# Special variables set by jam:
#   $(<) - targets of a rule (to the left of the :)
#   $(>) - sources of a rule (to the right of the :)
#   $(xxx) - true on xxx (UNIX, VMS, NT, OS2, MAC)
#   $(OS) - name of OS - varies wildly
#   $(JAMVERSION) - version number (3.0)
#
# Special variables used by jam:
#   SEARCH - where to find something (used during binding and actions)
#   LOCATE - where to plop something not found with SEARCH
#   HDRRULE - rule to call to handle include files
#   HDRSCAN - egrep regex to extract include files
#   HCACHEFILE - name of the header dependency cache
#   HCACHEMAXAGE - maximum age a cache entry can have before it is purged
#
# Special targets:
#   all - default if none given on command line
#


#========================================================================
# rule Split STRINGS : SPLIT_CHARACTERS
#========================================================================
#
# Splits each of the STRINGS at SPLIT_CHARACTERS. All splits are
# returned as a string list.
#
# Parameters:
#    STRINGS 	        The list of strings to split at the points specified by SPLIT_CHARACTERS.
#    SPLIT_CHARACTERS   One or more characters to split the list of
#                       STRINGS at. If the string starts with % the
#                       number afterward is converted to the following
#                       ascii character code.
#                       The Strings %t, %n and %r are converted to
#                       their matching ascii code.
#                       %nl Split at any new line character
#                       %s Space or tab character
#                       %w Split at any new line, space or tab character
#

#========================================================================
# rule Bash COMMANDS ;
#========================================================================
#
# The Bash rule is used to execute one or more COMMANDS and return
# the output to the user. Each command specified in the COMMANDS list
# is executed immediately, one after another. The results of a command
# execution are returned to the caller.
#
# Parameters:
#   COMMANDS 	A list of one or more commands, each executed serially.
#
#>> # Copy file1.txt to file2.txt, ignoring output.
#>> Bash "cp file1.txt file2.txt" ;
#>>
#>> # Grab a directory listing.
#>> dir_listing = [ Bash ls ] ;
#>>
#>> # Grab two directory listings.
#>> dir_listings = [ Bash "ls *.tga" "ls *.png" ]
#>> Echo dir *.tga - $(dir_listings[1]) ;
#>> Echo dir *.png - $(dir_listings[2]) ;
#

#========================================================================
# rule Match REGEXPS : LIST ;
#========================================================================
# Matches the egrep(1) style regular expressions REGEXPS against the
# strings in LIST. The result is the concatenation of matching ()
# subexpressions for each string in LIST, and for each regular
# expression in REGEXPS. Only useful within the [ ] construct, to
# change the result into a list.

#========================================================================
# rule Math LEFT OPERATOR RIGHT ;
#========================================================================
# Calculates the result of the simple math equation of the form LEFT
# OPERATOR RIGHT. Useful only within the [ ] construct, to change the
# result into a list.
# - Parameters:
#     LEFT  	An integer for the left side of the equation.
#     OPERATOR 	+ for addition, - for subtraction, * for multiplication, / for division, and % for modulus.
#     RIGHT 	An integer for the right side of the equation.
# - Returns:
#     Returns the result of the equation.

#========================================================================
# rule Subst LIST : PATTERN [ : REPL [ : MAXN ] ] ;
#========================================================================
# Note: The Subst rule comes from the Lua code base's implementation
#       of string.gsub. The documentation below is near verbatim from
#       the Lua manual.
#
# Returns a copy of LIST in which all occurrences of the PATTERN have
# been replaced by a replacement string specified by REPL. Only useful
# within the [ ] construct, to change the result into a list.
#
# The character % works as an escape character: any sequence in repl
# of the form n, with n between 1 and 9, stands for the value of the
# n-th captured substring (see below). The sequence 0 stands for the
# whole match. The sequence %% stands for a single %.
#
# The optional last parameter n limits the maximum number of
# substitutions to occur. For instance, when n is 1 only the first
# occurrence of pattern is replaced.
#
# Parameters:
#
#    	LIST: The list of strings to apply the regular expression
#    	       substitution algorithm to.
#
#    	PATTERN: The regular expression pattern to search for within
#    	         LIST. If the pattern is found, it is replaced with REPL.
#
#    	REPL: (optional) If specified, any patterns matched with
#    	      PATTERN are replaced with the contents of REPL. If not
#    	      specified, the replacement string is empty.
#
#    	MAXN: (optional) The maximum number of substitutions to occur.
#
#>> # __/__/dir/__/dir2
#>> Echo [ Subst ../../dir/../dir2 : %.%. : __ ] ;
#>>
#>> # hello hello world world
#>> Echo [ Subst "hello world" : "(%w+)" : "%1 %1" ] ;
#>>
#>> # hello hello world
#>> Echo [ Subst "hello world" : "%w+" : "%0 %0" : 1 ] ;
#>>
#>> # world hello Lua from
#>> Echo [ Subst "hello world from Lua" : "(%w+)%s*(%w+)" : "%2 %1" ] ;
#
# Patterns
# Character Class:
#
# A character class is used to represent a set of characters. The
# following combinations are allowed in describing a character class:
#
#    x: (where x is not one of the magic characters ^$()%.[]*+-?) represents the character x itself.
#
#    .: (a dot) represents all characters.
#
#    a: represents all letters.
#
#    c: represents all control characters.
#
#    d: represents all digits.
#
#    l: represents all lowercase letters.
#
#    p: represents all punctuation characters.
#
#    s: represents all space characters.
#
#    u: represents all uppercase letters.
#
#    w: represents all alphanumeric characters.
#
#    x: represents all hexadecimal digits.
#
#    z: represents the character with representation 0.
#
#    %x: (where x is any non-alphanumeric character) represents the
#        %character x. This is the standard way to escape the magic
#        %characters. Any punctuation character (even the non magic)
#        %can be preceded by a '%' when used to represent itself in a
#        %pattern.
#
#    [set]: represents the class which is the union of all characters
#           in set. A range of characters may be specified by
#           separating the end characters of the range with a '-'. All
#           classes %x described above may also be used as components
#           in set. All other characters in set represent
#           themselves. For example, [w_] (or [_w]) represents all
#           alphanumeric characters plus the underscore,
#
#    [0-7] represents the octal digits, and [0-7l-] represents the
#          octal digits plus the lowercase letters plus the '-'
#          character.
#
#    The interaction between ranges and classes is not
#    defined. Therefore, patterns like [a-z] or [a-%%] have no
#    meaning.
#
#    [^set]: represents the complement of set, where set is interpreted as above.
#
# For all classes represented by single letters (a, c, etc.), the
# corresponding uppercase letter represents the complement of the
# class. For instance, S represents all non-space characters.
#
# The definitions of letter, space, and other character groups depend
# on the current locale. In particular, the class [a-z] may not be
# equivalent to l.
#
# Pattern Item: A pattern item may be
#
#     a single character class, which matches any single character in the class;
#
#     a single character class followed by '*', which matches 0 or
#     more repetitions of characters in the class. These repetition
#     items will always match the longest possible sequence;
#
#     a single character class followed by '+', which matches 1 or
#     more repetitions of characters in the class. These repetition
#     items will always match the longest possible sequence;
#
#     a single character class followed by '-', which also matches 0
#     or more repetitions of characters in the class. Unlike '*',
#     these repetition items will always match the shortest possible
#     sequence;
#
#     a single character class followed by '?', which matches 0 or 1
#     occurrence of a character in the class;
#
#     %n, for n between 1 and 9; such item matches a substring equal
#     %to the n-th captured string (see below);
#
#     bxy, where x and y are two distinct characters; such item
#     matches strings that start with x, end with y, and where the x
#     and y are balanced. This means that, if one reads the string
#     from left to right, counting +1 for an x and -1 for a y, the
#     ending y is the first y where the count reaches 0. For instance,
#     the item b() matches expressions with balanced parentheses.
#
# Pattern:
#
#     A pattern is a sequence of pattern items. A '^' at the beginning
#     of a pattern anchors the match at the beginning of the subject
#     string. A '$' at the end of a pattern anchors the match at the
#     end of the subject string. At other positions, '^' and '$' have
#     no special meaning and represent themselves.  Captures:
#
#     A pattern may contain sub-patterns enclosed in parentheses; they
#     describe captures. When a match succeeds, the substrings of the
#     subject string that match captures are stored (captured) for
#     future use. Captures are numbered according to their left
#     parentheses. For instance, in the pattern "(a*(.)%w(%s*))", the
#     part of the string matching "a*(.)%w(%s*)" is stored as the
#     first capture (and therefore has number 1); the character
#     matching "<code>.</code>" is captured with number 2, and the
#     part matching "<code>%s*</code>" has number 3.
#
#     As a special case, the empty capture () captures the current
#     string position (a number). For instance, if we apply the
#     pattern "()aa()" on the string "flaaap", there will be two
#     captures: 3 and 5.
#
#     A pattern cannot contain embedded zeros. Use z instead.
#

# jambase version
JAMBASEDATE = 2008.11.22 ;

#
# Initialize variables
#
if $(LINT_C) && $(LINT_H) {
  # CAN_LINT = 1 ;
  CAN_LINT = 0 ; # Lint breaks Flymake for Android build...
}
if ( $(FLYMAKE) = 1 ) && ( $(CAN_LINT) = 1 ) {
  LINT_OBJECTS = 1 ;
}

switch $(HAM_TOOLSET) {
  case GCC :
    # Empty...
  case MINGW :
    NT = 1 ;
    WINDOWS = 1 ;
    if $(HAM_TOOLSET_NAME) = GCC4_X86 {
      OSPLAT = X86 ;
    }
    else if $(HAM_TOOLSET_NAME) = GCC4_X64 {
      OSPLAT = X64 ;
    }
  case VISUALC :
    NT = 1 ;
    WINDOWS = 1 ;
    if $(HAM_TOOLSET_NAME) = VC9_X86 || $(HAM_TOOLSET_NAME) = VC10_X86 {
      OSPLAT = X86 ;
    }
    else if $(HAM_TOOLSET_NAME) = VC9_X64 || $(HAM_TOOLSET_NAME) = VC10_X64 {
      OSPLAT = X64 ;
    }
  case EMBGCC :
    EMBGCC = 1 ;
  case IOS :
    IOS = 1 ;
  case ANDROID :
    ANDROID = 1 ;
  case JSCC :
    JSCC = 1 ;
  case * :
  {
    Echo  "Ham cannot be run because no known compilation toolset is setup." ;
    Exit  ;
  }
}
if $(NT) {
  ENVPATHSEP = ";" ;
}
else {
  ENVPATHSEP ?= ":" ;
}

######################################################################
#
#   C/C++ -> JavaScript compiler
#
######################################################################
if $(JSCC) = 1 {
  if ! $(EMSCRIPTEN_ROOT) {
    Exit "EMSCRIPTEN_ROOT not defined with JSCC toolset !" ;
  }
  if ! $(AGLDEVENVSRC) {
    Exit "AGLDEVENVSRC not defined with JSCC toolset !" ;
  }
  if ! $(WORKTEMP) {
    Exit "WORKTEMP not defined with JSCC toolset !" ;
  }

  if $(JSCC_EMU) {
    if $(JSCC_EMU) = VC10 {
      MSVCNT ?= $(MSVCDIR) ;
      AR     ?= lib ;
      CC     = $(HAM_CL) -nologo ;
      C++    = $(HAM_CL) -nologo ;
      LINK   = $(HAM_LINK) -nologo -INCREMENTAL:NO ;
      LINKLIBS += user32.lib gdi32.lib ;
      SUFLIB ?= .lib ;
      SUFDLL ?= .dll ;
    }
    else if $(JSCC_EMU) = CLANG {
      AR        = ar ru ;
      CC        = clang -m32 -isystem$(INCLUDE) ;
      C++       = clang++ -m32 -isystem$(INCLUDE) ;
      LINK      = clang++ -static -static-libstdc++ -static-libgcc -m32 -isystem$(INCLUDE) -L$(LIB) ;
    }
    else if $(JSCC_EMU) = GCC {
      AR        = ar ru ;
      CC        = gcc -m32 -I$(INCLUDE) ;
      C++       = g++ -m32 -I$(INCLUDE) ;
      LINK      = g++ -static -static-libstdc++ -static-libgcc -m32 -I$(INCLUDE) -L$(LIB) ;
    }
    else {
      EXIT "Unknown JSCC_EMU: " $(JSCC_EMU) ;
    }
  }
  else {
    AR        = $(EMSCRIPTEN_ROOT)/emar ru ;
    CC        = $(AGLDEVENVSRC)/scripts/ni-jscc ;
    C++       = $(AGLDEVENVSRC)/scripts/ni-js++ ;
    LINK      = $(AGLDEVENVSRC)/scripts/ni-jsld ;
  }

  CCFLAGS = -DJSCC -D__JSCC__ ;
  if $(JSCC_EMU) {
    CCFLAGS += -D__JSCC_EMU__ ;
  }
  else {
    CCFLAGS += -D__JSCC_WEB__ ;
  }
  C++FLAGS = $(CCFLAGS) ;

  if $(JSCC_EMU) = VC10 {
  }
  else {
    CCFLAGS += -fvisibility=hidden ;
    C++FLAGS += $(CCFLAGS) -fno-rtti -fno-exceptions ;
  }

  LINKLIBS  ?= ;
  OPTIM     ?= ;
  if $(JSCC_EMU) {
    SUFEXE    = .exe ;
  }
  else {
    SUFEXE    ?= .html ;
  }
  SUFOBJ    ?= .o ;
  SUFLIB    ?= .a ;
  SUFDLL    ?= .so ;
  SLASH     ?= / ;
}
######################################################################
#
#   Embedded Linux (STi7108)
#
######################################################################
else if $(EMBGCC) = 1 {
  if ! $(EMB_DEVICE) {
    Exit "EMB_DEVICE not defined with EMBGCC toolset !" ;
  }
  if ! $(EMB_ARCH) {
    Exit "EMB_ARCH not defined with EMBGCC toolset !" ;
  }
  if ! $(GCCBASE) {
    Exit "GCCBASE not defined with EMBGCC toolset !" ;
  }
  if ! $(GCCEXEBASE) {
    Exit "GCCEXEBASE not defined with EMBGCC toolset !" ;
  }

  CC        ?= $(GCCEXEBASE)gcc ;
  AR        ?= $(GCCEXEBASE)ar -ru ;
  C++       ?= $(CC) ;
  LINK      ?= $(CC) ;

  PICFLAGS = -fpic ;

  EMBGCC_PP_ARGS =
  -g
  -D__EMBGCC__
  -D__LITTLE_ENDIAN__
  -finput-charset=UTF-8
  -Wall
  -Wno-psabi
  -Wno-trigraphs
  -Wno-sign-compare
  -Wno-unknown-pragmas
  -Wno-switch
  -Wno-comment
  -Wno-unused
  -Wno-uninitialized
  ;

  EMBGCC_CC_ARGS += -fpic -fvisibility=hidden ;
  EMBGCC_CPP_ARGS = -fno-rtti -fno-exceptions -Wno-reorder ;

  EMBGCC_LINK_BASE_ARGS = -L$(ADRDIRNDKUSR)/lib ;
  EMBGCC_LINK_EXE_ARGS = $(EMBGCC_LINK_BASE_ARGS) ;
  EMBGCC_LINK_DLL_ARGS = $(EMBGCC_LINK_BASE_ARGS) -Wl,-shared ;
  SYSTEM_LINKLIBS = -lc -lstdc++ -lm -ldl -lpthread ;

  CCFLAGS   ?= $(EMBGCC_PP_ARGS) $(EMBGCC_CC_ARGS) ;
  C++FLAGS  ?= $(CCFLAGS) $(EMBGCC_CPP_ARGS) ;
  LINKFLAGS ?= ;
  LINKLIBS  ?= ;
  OPTIM     ?= ;
  SUFEXE    = .html ;
  SUFOBJ    = .o ;
  SUFLIB    = .a ;
  SUFDLL    = .so ;
  PREFIXDLL = lib ;
  SLASH     = / ;
}
######################################################################
#
#   Embedded Linux (STi7108)
#
######################################################################
else if $(EMBGCC) = 1 {
  if ! $(EMB_DEVICE) {
    Exit "EMB_DEVICE not defined with EMBGCC toolset !" ;
  }
  if ! $(EMB_ARCH) {
    Exit "EMB_ARCH not defined with EMBGCC toolset !" ;
  }
  if ! $(GCCBASE) {
    Exit "GCCBASE not defined with EMBGCC toolset !" ;
  }
  if ! $(GCCEXEBASE) {
    Exit "GCCEXEBASE not defined with EMBGCC toolset !" ;
  }

  CC        ?= $(GCCEXEBASE)gcc ;
  AR        ?= $(GCCEXEBASE)ar -ru ;
  C++       ?= $(CC) ;
  LINK      ?= $(CC) ;

  PICFLAGS = -fpic ;

  EMBGCC_PP_ARGS =
  -g
  -D__EMBGCC__
  -D__LITTLE_ENDIAN__
  -finput-charset=UTF-8
  -Wall
  -Wno-psabi
  -Wno-trigraphs
  -Wno-sign-compare
  -Wno-unknown-pragmas
  -Wno-switch
  -Wno-comment
  -Wno-unused
  -Wno-uninitialized
  ;

  EMBGCC_CC_ARGS += -fpic -fvisibility=hidden ;
  EMBGCC_CPP_ARGS = -fno-rtti -fno-exceptions -Wno-reorder ;

  EMBGCC_LINK_BASE_ARGS = -L$(ADRDIRNDKUSR)/lib ;
  EMBGCC_LINK_EXE_ARGS = $(EMBGCC_LINK_BASE_ARGS) ;
  EMBGCC_LINK_DLL_ARGS = $(EMBGCC_LINK_BASE_ARGS) -Wl,-shared ;
  SYSTEM_LINKLIBS = -lc -lstdc++ -lm -ldl -lpthread ;

  CCFLAGS   ?= $(EMBGCC_PP_ARGS) $(EMBGCC_CC_ARGS) ;
  C++FLAGS  ?= $(CCFLAGS) $(EMBGCC_CPP_ARGS) ;
  LINKFLAGS ?= ;
  LINKLIBS  ?= ;
  OPTIM     ?= ;
  SUFEXE    = ;
  SUFOBJ    = .o ;
  SUFLIB    = .a ;
  SUFDLL    = .so ;
  PREFIXDLL = lib ;
  SLASH     = / ;
}
######################################################################
#
#   IOS (iPhone/iPad)
#
######################################################################
else if $(IOS) = 1 {
  if ! $(IOS_ARCH) {
    Exit "IOS_ARCH not set while using IOS toolset !" ;
  }
  if ! $(IOS_PLAT) {
    Exit "IOS_PLAT not set while using IOS toolset !" ;
  }
  if ! $(IOS_DEVDIR) {
    Exit "IOS_DEVDIR not set while using IOS toolset !" ;
  }
  if ! $(IOS_TARGET) {
    Exit "IOS_TARGET not set while using IOS toolset !" ;
  }
  if ! $(IOS_SDKROOT) {
    Exit "IOS_SDKROOT not set while using IOS toolset !" ;
  }
  if ! $(IOS_AR) {
    Exit "IOS_AR not set while using IOS toolset !" ;
  }
  if ! $(IOS_CC) {
    Exit "IOS_CC not set while using IOS toolset !" ;
  }

  AR        = $(IOS_AR) -ru ;
  CC        = $(IOS_CC) ;
  C++       = $(IOS_CC) ;
  LINK      = $(IOS_CC) ;

  CCFLAGS =
    -DIPHONE
    -D__IOS__
    -fconstant-cfstrings
    -fno-strict-aliasing
    -Wno-trigraphs
    -pipe
    -mdynamic-no-pic
    -fvisibility=hidden
    -fpascal-strings
    -fmessage-length=0
  ;
  if $(IOS_STDTOOLCHAIN) = 1 {
    CCFLAGS +=
    -arch $(IOS_ARCH)
    -isysroot $(IOS_SDKROOT)
    ;
  }
  else {
    CCFLAGS =
    -I$(GCCDIR)/sys/usr/include/c++/4.2.1
    -I$(GCCDIR)/sys/usr/include/c++/4.2.1/armv6-apple-darwin9
    -I$(GCCDIR)/lib/gcc/arm-apple-darwin9/4.2.1/include
    $(CCFLAGS) ;
  }
  if $(IOS_STDTOOLCHAIN) = 1 {
    LINKFLAGS =
    -arch $(IOS_ARCH)
    -isysroot $(IOS_SDKROOT)
    -fvisibility=hidden
    -Wl,-dead_strip
    ;
  }
  else {
    LINKFLAGS =
    -framework CoreFoundation
    -framework Foundation
    -framework UIKit
    -framework OpenGLES
    -framework QuartzCore
    -lstdc++
    ;
  }

  if $(HAM_TOOLSET_NAME) = IOS_SIM {
    CCFLAGS += -DTARGET_OS_IPHONE -DTARGET_IPHONE_SIMULATOR -D__IOS_SIM__ -D__IPHONE_OS_VERSION_MIN_REQUIRED=20000 -mmacosx-version-min=10.5 ;
  }
  else if $(HAM_TOOLSET_NAME) = IOS_HW {
    CCFLAGS += -DTARGET_OS_IPHONE -D__IOS_HW__ ;
    if $(IOS_STDTOOLCHAIN) = 1 {
      CCFLAGS += -miphoneos-version-min=$(IOS_TARGET) ;
      LINKFLAGS += -miphoneos-version-min=$(IOS_TARGET) ;
    }
  }
  else {
    Exit "Invalid HAM_TOOLSET_NAME !" ;
  }
  C++FLAGS  = $(CCFLAGS) -fno-rtti -fno-exceptions -fvisibility-inlines-hidden ;
  LINKLIBS  ?= ;
  OPTIM     ?= ;
  SUFEXE    = .$(IOS_ARCH) ;
  SUFOBJ    = .o ;
  SUFLIB    = .a ;
  SUFDLL    = .dylib ;
  SLASH     = / ;
}
######################################################################
#
#   Android
#
######################################################################
else if $(ANDROID) = 1 {
  if ! $(ADRDIRNDK) {
    Exit "ADRDIRNDK not set while using ANDROID NDK toolset !" ;
  }
  ADRDIRNDK = $(ADRDIRNDK:/) ;

  if ! $(ADRDIRNDKUSR) {
    Exit "ADRDIRNDKUSR not set while using ANDROID NDK toolset !" ;
  }
  ADRDIRNDKUSR = $(ADRDIRNDKUSR:/) ;

  if ! $(ADRGCCDIR) {
    Exit "ADRGCCDIR not set while using ANDROID NDK toolset !" ;
  }
  ADRGCCDIR = $(ADRGCCDIR:/) ;

  if ! $(ADRGCCVER) {
    Exit "ADRGCCVER not set while using ANDROID NDK toolset !" ;
  }
  ADRGCCVER = $(ADRGCCVER:/) ;

  if ! $(GCCDIR) {
    Exit "GCCDIR not set while using ANDROID NDK toolset !" ;
  }
  GCCDIR = $(GCCDIR:/) ;

  if ! $(GCCVER) {
    Exit "GCCVER not set while using ANDROID NDK toolset !" ;
  }
  GCCVER = $(GCCVER:/) ;

  if ! $(GCCEXEBASE) {
    Exit "GCCEXEBASE not set while using ANDROID NDK toolset !" ;
  }

  if $(SYSROOT) {
    CC        ?= $(GCCEXEBASE)gcc --sysroot=$(SYSROOT) ;
  }
  else {
    CC        ?= $(GCCEXEBASE)gcc ;
  }
  AR        ?= $(GCCEXEBASE)ar -ru ;
  C++       ?= $(CC) ;
  LINK      ?= $(CC) ;

  PICFLAGS = -fpic ;

  ANDROID_CC_ARGS =
  -g
  -fpic
  -fno-strict-aliasing
  -mthumb-interwork
  -ffunction-sections
  -funwind-tables
  -fstack-protector
  -fno-short-enums
  -fvisibility=hidden
  -D__ARM_ARCH_5__
  -D__ARM_ARCH_5T__
  -D__ARM_ARCH_5E__
  -D__ARM_ARCH_5TE
  -DANDROID
  -D__LITTLE_ENDIAN__
  -I$(ADRDIRNDKUSR)/include
  -finput-charset=UTF-8
  -Werror -Wall
  -Wno-psabi -Wno-trigraphs -Wno-sign-compare
  -Wno-unknown-pragmas -Wno-switch -Wno-comment
  -Wno-unused -Wno-uninitialized
  ;

  switch $(HAM_TOOLSET_VER)
  {
      ## ARMv5TE no FPU
    case ARMv5 :
      ANDROID_CC_ARGS +=
      -D__CPU_ARMv5__
      -march=armv5te
      -mtune=xscale
      -msoft-float
      -DaglAtomicC
      -mthumb
      ;
      ## ARM6+ VFP (TC8900, Qualcomm 7227, ...)
    case ARMv6 :
      ANDROID_CC_ARGS +=
      -D__CPU_ARMv6__
      -march=armv6
      -mfpu=vfp
      -mfloat-abi=softfp
      ;
      ## ARM7A VFPv3 (Cortex A8, NVidia Tegra 2, HTC Desire, ...)
    case ARMv7A :
      ANDROID_CC_ARGS +=
      -D__CPU_ARMv7A__
      -march=armv7-a
      -mfpu=vfpv3
      -mfloat-abi=softfp
      ;
      ANDROID_LINK_BASE_ARGS = -Wl,--fix-cortex-a8 ;
      ## ARM7N ARMV7A + NEON
    case ARMv7N :
      ANDROID_CC_ARGS +=
      -D__CPU_ARMv7N__
      -D__CPU_ARM_NEON__
      -march=armv7-a
      -mfpu=neon
      -mfloat-abi=softfp
      ;
      ANDROID_LINK_BASE_ARGS = -Wl,--fix-cortex-a8 ;
    case * :
      Exit "Invalid Android Toolset version '" $(HAM_TOOLSET_VER) "' !" ;
  }
  ANDROID_CPP_ARGS +=
  -fno-rtti -fno-exceptions
  -Wno-reorder # Warnings valid for C++ only
  ;

  ANDROID_LINK_BASE_ARGS +=
  -L$(ADRDIRNDKUSR)/lib
  -nostdlib
  ;

  ANDROID_LINK_EXE_ARGS = $(ANDROID_LINK_BASE_ARGS)
  -ffunction-sections
  -fdata-sections
  -Bdynamic
  -Wl,-dynamic-linker,//system/bin/linker
  -Wl,--gc-sections
  -Wl,-z,nocopyreloc
  -Wl,--no-undefined
  -Wl,-rpath-link=$(ADRDIRNDKUSR)/lib
  $(ADRDIRNDKUSR)/lib/crtend_android.o
  $(ADRDIRNDKUSR)/lib/crtbegin_dynamic.o
  ;

  ANDROID_LINK_DLL_ARGS = $(ANDROID_LINK_BASE_ARGS)
  -ffunction-sections
  -fdata-sections
  -Wl,--gc-sections
  -Wl,-z,nocopyreloc
  -Wl,--no-undefined
  -Wl,-shared,-Bsymbolic
  -Wl,--no-whole-archive
  -Wl,-rpath-link=$(ADRDIRNDKUSR)/lib
  ;

  SYSTEM_LINKLIBS = $(ADRGCCDIR)/lib/gcc/$(GCCBASE)/$(ADRGCCVER)/libgcc.a -llog -lc -lstdc++ -lm -ldl ;

  CCFLAGS   ?= $(ANDROID_CC_ARGS) ;
  C++FLAGS  ?= $(CCFLAGS) $(ANDROID_CPP_ARGS) ;
  LINKFLAGS ?= ;
  LINKLIBS  ?= ;
  OPTIM     ?= ;
  SUFEXE    = .arm ;
  SUFOBJ    = .o ;
  SUFLIB    = .a ;
  SUFDLL    = .so ;
  PREFIXDLL = lib ;
  SLASH     = / ;
}
######################################################################
#
#   NT (Windows)
#
######################################################################
else if $(NT) = 1
{
  SLASH   ?= / ;
  SUFLIB  ?= .lib ;
  SUFOBJ  ?= .obj ;
  SUFEXE  ?= .exe ;
  SUFDLL  ?= .dll ;
  ERLSHELLW ?= werl ;
  CHMOD   ?= chmod ;

  if $(OSPLAT) = X64 {
    YASM = "yasm_x64" ;
	YASMFLAGS   = "-m amd64 -f coff" ;
  }
  else {
    YASM = "yasm_x86" ;
	YASMFLAGS   = "-m x86 -f coff" ;
  }

  if $(HAM_TOOLSET) = CLANG
  {
    CC_BASE = -I$(INCLUDE) -DCLANG_NT -D_MSC_VER=1500 ; # -Wno-missing-declarations -Wno-invalid-token-paste -Wno-unused-value ;
	AR              ?= ar -ru ;
	CC              ?= clang $(CC_BASE)  ;
	CCFLAGS         ?= "" ;
	C++             ?= clang $(CC_BASE) ;
	C++FLAGS        ?= $(CCFLAGS) ;
	LINK            ?= gcc -L$(LIB) -DCLANG_NT ;
	LINKFLAGS       ?= ;
	LINKLIBS        ?= ;
	OPTIM           ?= ;
	SUFOBJ          = .o ;
	SUFLIB          = .a ;
	SLASH           = / ;
  }
  else if $(HAM_TOOLSET) = VISUALC
  {
    # CC_ISCLANG   = 1 ;

	# Visual C++ 6.0 uses MSVCDIR
	MSVCNT      ?= $(MSVCDIR) ;
	# bury IA64 in the path for the SDK
	local I ; if $(OSPLAT) = IA64 { I = ia64/ ; } else { I = "" ; }
	AR          ?= lib ;

    if ! ( $(FLYMAKE) = 1 ) {
      # Errors with absolute file path
      HAM_CL = $(HAM_CL) -FC ;
    }

    if $(CC_ISCLANG) = 1 {
      CC          ?= clang ;
      CCFLAGS     = -Wno-microsoft -Wno-unused-value ;
    }
    else {
      CC          ?= $(HAM_CL) -nologo ;
      CCFLAGS     ?= ;
    }
    C++FLAGS    ?= ;
	C++         ?= $(HAM_CL) -nologo ;
	LINK        ?= $(HAM_LINK) -nologo -INCREMENTAL:NO ;
	LINKFLAGS   ?= "" ;
	LINKLIBS    ?= oldnames.lib kernel32.lib ;
	OPTIM       ?= "" ;
	STDHDRS     ?= $(VISUALC)/include ;
	UNDEFFLAG   ?= "-u _" ;
  }
  else if $(HAM_TOOLSET) = INTELC
  {
	if ! $(VISUALC)
	{
	  Echo "As a special exception, when using the Intel C++ compiler, you need" ;
	  Echo "to define the VISUALC environment variable to indicate the location" ;
	  Echo "of your Visual C++ installation. Aborting.." ;
	  Exit ;
	}

	AR          ?= lib ;
	CC          ?= icl -nologo ;
	CCFLAGS     ?= "" ;
	C++         ?= $(CC) ;
	C++FLAGS    ?= $(CCFLAGS) ;
	LINK        ?= xilink -nologo ;
	LINKFLAGS   ?= "" ;
	LINKLIBS    ?= advapi32.lib oldnames.lib kernel32.lib ;
	OPTIM       ?= "" ;
	STDHDRS     ?= $(INTELC)/include $(VISUALC)/include ;
	UNDEFFLAG   ?= "-u _" ;
  }
  else if $(HAM_TOOLSET) = MINGW
  {
	AR              ?= ar -ru ;
	CC              ?= gcc ;
	CCFLAGS         ?= "" ;
	C++             ?= gcc ;
	C++FLAGS        ?= $(CCFLAGS) ;
	LINK            ?= gcc ;
	LINKFLAGS       ?= -mconsole ;
	LINKLIBS        ?= "" ;
	OPTIM           ?= ;
	SUFOBJ           = .o ;
	SUFLIB           = .a ;
	SLASH            = / ;
	#       NOARSCAN        ?= true ;
  }
  else if $(HAM_TOOLSET) = DIGITALMARS
  {
	AR              ?= lib -c ;
	CC              ?= dmc ;
	CCFLAGS         ?= "" ;
	C++             ?= $(CC) ;
	C++FLAGS        ?= $(CCFLAGS) ;
	LINK            ?= link /nologo ;
	LINKFLAGS       ?= "/EXETYPE:NT /NOMAP" ;
	LINKLIBS        ?= USER32.LIB KERNEL32.LIB GDI32.LIB ;
	OPTIM           ?= ;
	NOARSCAN         = true ;
	PICFLAGS         = -mn -WD ;
  }

  STDHRS ?= "" ;
}

# shared library object file suffix. We assume that it is identical
# than the normal one
PREFIXDLL ?= "" ;
SUFDLLOBJ ?= $(SUFOBJ) ;
SUFDLL ?= $(SUFLIB) ;

# the D compiler
DC ?= dmd ;

#
# General defaults; a lot like UNIX
#

AR      ?= ar ru ;
AS      ?= as ;
ASFLAGS     ?= ;
YASM    ?= nasm ;
YASMFLAGS    ?= ;
AWK     ?= awk ;
BINDIR      ?= /usr/local/bin ;
C++     ?= cc ;
C++FLAGS    ?= ;
CC      ?= cc ;
CCFLAGS     ?= ;
CP      ?= cp -f ;
CP_PRESERVE ?= $(CP) -p ;
CRELIB      ?= ;
DOT     ?= . ;
DOTDOT      ?= .. ;
EXEMODE     ?= 711 ;
FILEMODE    ?= 644 ;
FILEMODERO  ?= -w ;
FORTRAN     ?= f77 ;
FORTRANFLAGS    ?= ;
HDRS        ?= ;
INSTALLGRIST    ?= installed ;
JAMFILE     ?= _build.ham ;
JAMRULES    ?= _rules.ham ;
LEX     ?= ;
LIBDIR      ?= /usr/local/lib ;
LINK        ?= $(CC) ;
LINKFLAGS   ?= ;
LINKLIBS    ?= ;
SYSTEM_LINKLIBS ?= ;
LN      ?= ln ;
MANDIR      ?= /usr/local/man ;
MKDIR       ?= mkdir -p ;
MV      ?= mv -f ;
OPTIM       ?= ;
RCP     ?= rcp ;
RM      ?= rm -f ;
RMDIR       ?= $(RM) ;
RSH     ?= rsh ;
SED     ?= sed ;
SHELLHEADER ?= "#!/bin/sh" ;
SHELLMODE   ?= 755 ;
SLASH       ?= / ;
QUOTE       ?= "\"" ;
SUBDIRRULES     ?= ;
SUBDIRRESET     ?= ASFLAGS YASMFLAGS HDRS C++FLAGS CCFLAGS ;
SUFEXE      ?= "" ;
SUFLIB      ?= .a ;
SUFOBJ      ?= .o ;
UNDEFFLAG   ?= "-u _" ;
YACC        ?= ;
YACCGEN     ?= ;
YACCFILES   ?= ;
YACCFLAGS   ?= ;
ERLC        ?= erlc ;
SUFBEAM     ?= .beam ;
ERLFLAGS    ?= -Wall ;
ERLOPTIM    ?= ;
ERLPATH     ?= ;
ERLHDRS     ?= ;
ERLSHELL    ?= erl ;
ERLSHELLW   ?= erl ;
ERLDEFS     ?= ;
RCFLAGS     ?= ;
SUFAQO      ?= .aq ;
SUFJAVAC    ?= .class ;

HDRPATTERN =
"^[ 	]*#[ 	]*include[ 	]*[<\"]([^\">]*)[\">].*$" ;

OSFULL = $(OS)$(OSVER)$(OSPLAT) $(OS)$(OSPLAT) $(OS)$(OSVER) $(OS) ;

#
# Base dependencies - first for "bootstrap" kinds of rules
#

Depends all : shell files lib exe obj beam ;
Depends all shell files lib exe obj beam : first ;
NotFile all first shell files lib exe obj beam dirs clean uninstall ;
Always  clean uninstall ;

#
# Rules
#

# /As object : source ;
#
# Assemble (.s) the file _source_, called by the @Object rule.
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule As
{
  Depends $(<) : $(>) ;
  ASFLAGS on $(<) += $(ASFLAGS) $(SUBDIRASFLAGS) ;
  ASHDRS on $(<) = [ FIncludes $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ] ;
}

# /Yasm object : source ;
#
# Assemble (.asm) the file _source_, called by the @Object rule.
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule Yasm
{
  Depends $(<) : $(>) ;
  YASMFLAGS on $(<) += $(YASMFLAGS) $(SUBDIRYASMFLAGS) ;
  YASMHDRS on $(<) = [ FIncludesDash $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ] ;
  YASMDEFS on $(<) = [ on $(<) FDefinesDash $(DEFINES) ] ;
}

rule Masm
{
  Depends $(<) : $(>) ;
}

# /Bulk  directory : sources ;
#
# Copies _sources_ into _directory_
#
rule Bulk
{
  local i ;

  for i in $(>)
  {
	File $(i:D=$(<)) : $(i) ;
  }
}


# /Dc object : source ;
#
# Compile the file source into object, usin the D compiler $(DC), its
# flags $(DCFLAGS) and $(DOPTIM)
# Called by the @Object rule
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule Dc
{
  Depends $(<) : $(>) ;

  # Just to clarify here: this sets the per-target DCFLAGS to
  # be the current value of (global) DCFLAGS and SUBDIRDCFLAGS.

  DCFLAGS on $(<) += $(DCFLAGS) $(SUBDIRDCFLAGS) ;
}

# /Erl object : source ;
#
# Compile the file source into beam, using the Erlang compiler $(ERLC), its
# flags $(ERLFLAGS) and $(ERLOPTIM)
# Called by the @Object rule
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule Erl
{
  Depends $(<) : $(>) ;

#   echo "ERLHDRS: " $(ERLHDRS) ;

  # Just to clarify here: this sets the per-target ERLFLAGS to
  # be the current value of (global) ERLFLAGS and SUBDIRERLFLAGS.

  ERLFLAGS on $(<) += $(ERLFLAGS) $(SUBDIRERLFLAGS) ;
  ERLDEFS on $(<) += $(ERLDEFS) ;
  ERLHDRS on $(<) = [ FIncludesDash $(SEARCH_SOURCE) $(ERLHDRS) $(SUBDIRHDRS) $(HDRS) ] ;
}

# /Cc object : source ;
#
# Compile the file source into object, using the C compiler $(CC), its
# flags $(CCFLAGS) and $(OPTIM), and the header file directories $(HDRS).
# Called by the @Object rule
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule Cc
{
  Depends $(<) : $(>) ;

  # If the compiler's -o flag doesn't work, relocate the .o

  if $(RELOCATE)
  {
	CcMv $(<) : $(>) ;
  }

  # Just to clarify here: this sets the per-target CCFLAGS to
  # be the current value of (global) CCFLAGS and SUBDIRCCFLAGS.
  # CCHDRS and CCDEFS must be reformatted each time for some
  # compiles (VMS, NT) that malign multiple -D or -I flags.

  CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) ;

  CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;
  CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;
}

# /C++ object : source ;
#
# Compile the C++ source file _source_. Similar to @CC, called by @Object
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule C++
{
  Depends $(<) : $(>) ;

  if $(RELOCATE)
  {
	CcMv $(<) : $(>) ;
  }

  C++FLAGS on $(<) += $(C++FLAGS) $(SUBDIRC++FLAGS) ;

  CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;
  CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;
}

# /Chmod target ;
#
# (Unix and VMS only). Change file permissions on _target_ to target-specific
# $(MODE) value set by @Link, @File, and @Shell rules
#
rule Chmod
{
  if $(CHMOD) { Chmod1 $(<) ; }
}

# /Clean  clean : targets ;
#
# Removes existing _targets_ when _clean_ is built. clean is not a dependency
# of all, and must be built explicitely for targets to be removed
#

# /File target : source ;
#
# Copies _source_ into _target_
#
rule File
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(FILEMODE) ;
  Chmod $(<) ;
}
# Same as file, but preserve time and attributes of the file
rule FilePreserve
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(FILEMODE) ;
  Chmod $(<) ;
}
rule FilePreserveRO
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(FILEMODERO) ;
  Chmod $(<) ;
}
actions FilePreserveRO
{
  $(CP_PRESERVE) $(>) $(<)
}

# Straight copy
rule Cp
{
  Depends $(<) : $(>) ;
}

# /Fortran object : source ;
#
# Compile the Fortran source file _source_. Called by the @Object rule
#
# Do not call this rule directly, since _obj_ and _source_ may have
# have platform-specific file extensions
#
rule Fortran
{
  Depends $(<) : $(>) ;
}

# /GenFile target : image sources ;
#
# Runs the command "_image_ _target_ _sources_" to create _target_ from
# _sources_ and _image_ (where _image_ is an executable built by the
# @Main rule)
#
rule GenFile
{
  local _t = [ FGristSourceFiles $(<) ] ;
  local _s = [ FAppendSuffix $(>[1]) : $(SUFEXE) ] ;
  Depends $(_t) : $(_s) $(>[2-]) ;
  GenFile1 $(_t) : $(_s) $(>[2-]) ;
  Clean clean : $(_t) ;
}

rule GenFile1
{
  MakeLocate $(<) : $(LOCATE_SOURCE) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

# /HardLink target : source ;
#
# Makes _target_ a hard link to _source_, if it isn't one already
# (Unix only)
#
rule HardLink
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

# /HdrMacroFile
#
# this rule is specific to FT-Jam. It is used to indicate that a given file
# contains definitions for filename macros (e.g. "#define MYFILE_H <myfile>.h")
# that can later be used in #include statements in the rest of the source
#
# these files must be parsed before any make is tried.
#
rule HdrMacroFile
{
  HDRMACRO $(<) ;
}

# /HdrRule source : headers ;
#
# Arranges the proper dependencies when the file _source_ includes the files
# _headers_ through the #include C preprocessor directive
#
# this rule is not intendend to be called explicitely. It is called
# automatically during header scanning on sources handled by the @Object
# rule (e.g. sources in @Main or @Library rules)
#
rule HdrRule
{
  # HdrRule source : headers ;

  # N.B.  This rule is called during binding, potentially after
  # the fate of many targets has been determined, and must be
  # used with caution: don't add dependencies to unrelated
  # targets, and don't set variables on $(<).

  # Tell Jam that anything depending on $(<) also depends on $(>),
  # set SEARCH so Jam can find the headers, but then say we don't
  # care if we can't actually find the headers (they may have been
  # within ifdefs),

  local s = $(>:G=$(HDRGRIST:E)) ;
  local t = $(HDRSEARCH) ;
  t += $(DEPHDRS) ;

#  Echo "MYHDR: " $(t) ;

  Includes $(<) : $(s) ;
  SEARCH on $(s) = $(HDRSEARCH) ;
  NoCare $(s) ;

  # Propagate on $(<) to $(>)

#   local t = $(HDRSEARCH) ;
#   Echo "MYHDR([$(<:D)]-[$(>:D)]): " $(HDRSEARCH) ;
#   for _i in $(HDRSEARCH) {
# 	t += [ FDirName $(_i) $(<:D) ] ;
# 	t += [ FDirName $(_i) $(>:D) ] ;
#   }
   t += $(HDROPENED:DC) ;
#  Echo "HDROPEN: " $(HDROPENED:D) ;

  HDRSEARCH on $(s) = $(t) ;
  HDRSCAN on $(s) = $(HDRSCAN) ;
  HDRRULE on $(s) = $(HDRRULE) ;
  HDRGRIST on $(s) = $(HDRGRIST) ;
}

# /Lex source.c : source.l ;
#
# Process the lex source file _source.l_ and rename the lex.yy.c
# to _source.c_ . Called by the @Object rule
#
rule Lex
{
  LexMv $(<) : $(>) ;
  Depends $(<) : $(>) ;
  MakeLocate $(<) : $(LOCATE_SOURCE) ;
  Clean clean : $(<) ;
}

# /Library  library : sources : objs ;
#
#  Compiles _sources_ and archives them into _library_. The intermediate
#  objects are deleted. Calles @Object and @LibraryFromObjects
#
#  If @Library is invoked with no suffix on _library_, the $(SUFLIB)
#  suffix is used
#
rule Library
{
  LibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) $(3) ;
  Objects $(>) ;
}

# /SharedLibrary  library : sources : def : import : objs ;
#
# Compiles _sources_ and generates a shared _library_ (i.e. DLL on Windows,
# or shared object on Unix). Calls @SharedObjects and @SharedLibraryFromObjects
#
# If @SharedLibrary is invoked with no suffix on _library_, then
# $(SUFDLL) suffix is used
#
# _def_ is the name of the corresponding definition file used to generate
# the library on Windows and OS/2 (ignored otherwise). If undefined, it
# will default to _library_ with the .def suffix
#
# _import_ is the name of the corresponding import library for Windows
# and OS/2 platforms (ignored otherwise). If undefined, it will default
# to _library_ with the .dll.lib suffix.
#
rule SharedLibrary
{
  SharedLibraryFromObjects $(<) : $(>:S=$(SUFDLLOBJ)) $(5) : $(3) : $(4) ;
  SharedObjects            $(>) ;
}

if $(UNIX)
{
  # this rule is used to find the 'libtool' script in the current
  # path, this is required when compiling shared objects on Unix
  #
  rule LibToolFind
  {
    if $(LIBTOOL) { return $(LIBTOOL) ; }

    local  matches = [ Glob $(PATH) : libtool ] ;

    if ! $(matches)
    {
      Exit "could not find 'libtool' program in current path. Aborting !" ;
    }
    LIBTOOL = $(matches[1]) ;

    return $(LIBTOOL) ;
  }
}

# /LibraryFromObjects library : objects ;
#
# Archives _objects_ into _library_. The _objects_ are then deleted
#
# If _library_ has no suffix, the $(SUFLIB) suffix is used
#
# Called by @Library rule. Most people should never call this rule
# directly.
#
rule LibraryFromObjects
{
  local _i _l _s ;

  # Add grist to file names

  _s = [ FGristFiles $(>) ] ;
  _l = $(<:S=$(SUFLIB)) ;

  # library depends on its member objects

  if $(DELOBJS)
  {
	Depends lib : $(_l) ;
  }
  else
  {
	Depends obj : $(_s) ;
  }

  # Set LOCATE for the library and its contents.  The bound
  # value shows up as $(NEEDLIBS) on the Link actions.
  # For compatibility, we only do this if the library doesn't
  # already have a path.

  if ! $(_l:D)
  {
	MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;
  }

  if ( ! $(DELOBJS) ) ||  $(NOARSCAN)
  {
	# If we can't scan the library to timestamp its contents,
	# we have to just make the library depend directly on the
	# on-disk object files.

	Depends $(_l) : $(_s) ;
  }
  else
  {
	# If we can scan the library, we make the library depend
	# on its members and each member depend on the on-disk
	# object file.

	Depends $(_l) : $(_l)($(_s:BS)) ;

	for _i in $(_s)
	{
	  Depends $(_l)($(_i:BS)) : $(_i) ;
	}
  }

  Clean clean : $(_l) ;

  if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

  Archive $(_l) : $(_s) ;

  if $(RANLIB) { Ranlib $(_l) ; }

  # If we can't scan the library, we have to leave the .o's around.

  if $(DELOBJS) && ! ( $(NOARSCAN) || $(NOARUPDATE) ) { RmTemps $(_l) : $(_s) ; }
}


# /SharedLibraryFromObjects  library : objects : def : import ;
#
# Equivalent of @LibraryFromObjects for shared libraries.
#
# Called by @SharedLibrary. Most people shouldn't call this rule
# directly
#
rule SharedLibraryFromObjects
{
  local _i _l _s ;

  # Add grist to file names

  _s = [ FGristFiles $(>) ] ;
  _l = $(<:S=$(SUFDLL)) ;

  #Echo "Library is $(_l)"    ;
  # library depends on its member objects

  if $(DELOBJS)
  {
	Depends lib : $(_l) ;
  }
  else
  {
	Depends obj : $(_s) ;
  }

  # Set LOCATE for the library and its contents.  The bound
  # value shows up as $(NEEDLIBS) on the Link actions.
  # For compatibility, we only do this if the library doesn't
  # already have a path.

  if ! $(_l:D)
  {
	MakeLocate $(_l) : $(LOCATE_TARGET) ;
  }

  # we never scan shared libraries for member objects
  Depends $(_l) : $(_s) ;

  Clean clean : $(_l) ;

  # I don't know if VMS supports shared libraries, so I prefer
  # to disable the following right now
  #
  #if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

  if $(OS) = LINUX || $(OS) = MACOSX
  {
	DllLink $(_l) : $(_s) ;
  }
  else if $(NT)
  {
	local  _implib = $(4) ;

	_implib ?= $(_l:S=$(SUFLIB)) ;

	Clean    clean : $(_implib) ;
	Depends  lib   : $(_implib) ;

	Depends $(_implib) : $(_l) ;
	Depends $(_l)      ;

	IMPLIBNAME  on $(_l) = $(_implib) ;

	MakeLocate $(_implib)        : $(LOCATE_TARGET) ;
	MakeLocate $(_implib:S=.exp) : $(LOCATE_TARGET) ;

	if $(HAM_TOOLSET) in VISUALC DIGITALMARS {
	  SharedLink-$(HAM_TOOLSET) $(_l) : $(_s) : $(_implib) ;
	}

	DllLink $(_l) : $(_s) ;
  }
  else
  {
	Echo "Sorry, I don't know how to make a shared library on your system" ;
	Exit "Please contact the Ham maintainer for help" ;
  }
}


# Since building shared libraries is so different depending on the
# compiler being used, I've broken this task into compiler-specific
# ones
#
#

# This contains the Visual C++ specific rule used to build a DLL
# and its import library
#
rule SharedLink-VISUALC
{
  # get rid of the '.exp/.ilk' files when cleaning
  #
  Clean  clean : $(3:S=.exp) ;
  Clean  clean : $(3:S=.ilk) ;
}


rule SharedLink-BORLANDC
{
  local  _implib  = $(3) ;

  LINKFLAGS on $(<) += /x /Gn /Tpd ;
  LINKLIBS on $(<) = $(LINKLIBS) $(ILINKLIBS) ;

  # Generate import library with the IMPLIB tool !!
  #
  DllImplib $(_implib) : $(<) ;
  Depends   $(_implib) : $(<) ;
  Depends   lib        : $(_implib) ;

  # clean the TDS file, since the compiler refuses to not generate it !
  MakeLocate $(<:S=.tds) : $(LOCATE_TARGET) ;
  Clean  clean : $(<:S=.tds) ;
}

rule SharedLink-WATCOM
{
  #Echo "Sorry, but building DLLs with Watcom isn't supported by this tool" ;
  #Echo "this comes from the fact that the Watcom linker isn't capable of"  ;
  #Echo "using normal .def files" ;
  #Exit ;

  local  _implib  = $(3) ;

  IMPLIB on $(<) = $(_implib) ;

  # clean the TDS file, since the compiler refuses to not generate it !
  MakeLocate $(<:S=.tds) : $(LOCATE_TARGET) ;
  Clean  clean : $(<:S=.tds) ;
}


rule SharedLink-DIGITALMARS
{
  #Echo "Sorry, but building DLLs with Digital Mars isn't supported at the" ;
  #Echo "moment, please contact the FT-Jam maintainers" ;
  #Exit ;
}


# /Link  image : objects ;
#
# Links _image_ from _objects_ and sets permissions on _image_ to
# $(EXEMODE). _image_ must be an actual filename; suffix is not
# supplied.
#
# Called by @Main, shouldn't be called by most people
#
rule Link
{
  MODE on $(<) = $(EXEMODE) ;
  Chmod $(<) ;
}

# /LinkLibraries image : libraries ;
#
# Makes _image_ depend on _libraries_ and includes them during linking
#
# _image_ may be referenced without a suffix in this rule invocation.
# @LinkLibraries supplies the suffix
#
# You should only use this rule with libraries created through the
# @Library rule. For external libraries, use something else (XXX)
#
rule LinkLibraries
{
  # make library dependencies of target
  # set NEEDLIBS variable used by 'actions Main'

  local _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

  Depends $(_t) : $(>:S=$(SUFLIB)) ;
  NEEDLIBS on $(_t) += $(>:S=$(SUFLIB)) ;
}

# /LinkSharedLibraries image : libraries :
#
# Same as @LinkLibraries, but to link _image_ with shared libraries
# generated through the @SharedLibrary rule
#
rule LinkSharedLibraries
{
  # make library dependencies of target
  # set NEEDLIBS variable used by 'actions Main'

  local _t   = [ FAppendSuffix $(<) : $(SUFEXE) ] ;
  local _ext = $(SUFDLL) ;

  if $(NT) || $(OS2)
  {
	# on NT or OS/2, we need to link agains the import library,
	# not the DLL itself !!
	#
	_ext = $(SUFDLL)$(SUFLIB) ;
  }
  Depends $(_t) : $(>:S=$(_ext))  ;
  NEEDLIBS on $(_t) += $(>:S=$(_ext)) ;
}

# /Main image : sources : objs ;
#
# Compiles _sources_ and links them into _image_. Calls @Objects and
# @MainFromObjects.
#
# _image_ may be supplied without suffix.
#
rule Main
{
  MainFromObjects $(<) : $(>:S=$(SUFOBJ)) $(3) ;
  Objects $(>) ;
}

# /MainFromObjects image : objects ;
#
# Links _objects_ into _image_. Dependency of exe.
# @MainFromObjects provides a default suffix for _image_
#
rule MainFromObjects
{
  local _s _t ;

  # Add grist to file names
  # Add suffix to exe

  _s = [ FGristFiles $(>) ] ;
  _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

  # so 'jam foo' works when it's really foo.exe

  if $(_t) != $(<)
  {
	Depends $(<) : $(_t) ;
	NotFile $(<) ;
  }

  # make compiled sources a dependency of target

  Depends exe : $(_t) ;
  Depends $(_t) : $(_s) ;
  MakeLocate $(_t) : $(LOCATE_TARGET) ;

  Clean clean : $(_t) ;

  # special case for stupid Borland C++, which always generates a
  # .tds file for executables, even when no debug information is needed
  #
  if $(HAM_TOOLSET) = BORLANDC {
	MakeLocate $(_t:S=.tds) : $(LOCATE_TARGET) ;
	Clean  clean : $(_t:S=.tds) ;
  }

  Link $(_t) : $(_s) ;
}

# /MakeLocate  targets : directory
#
# Creates _dir_ and causes _target_ to be built into _dir_
#
# This is done by setting the target-specific variable LOCATE
# on _targets_, and arranges with @MkDir to create the target
# directory
#
rule MakeLocate
{
  # Note we grist the directory name with 'dir',
  # so that directory path components and other
  # targets don't conflict.

  if $(>)
  {
	LOCATE on $(<) = $(>) ;
	Depends $(<) : $(>[1]:G=dir) ;
	MkDir $(>[1]:G=dir) ;
  }
}
rule MakeDir
{
  # Note we grist the directory name with 'dir',
  # so that directory path components and other
  # targets don't conflict.

  if $(>)
  {
	Depends $(<) : $(>[1]:G=dir) ;
	MkDir $(>[1]:G=dir) ;
  }
}

# /MkDir  dir ;
#
# Creates _dir_ and its parent directories
#
rule MkDir
{
  # Ignore timestamps on directories: we only care if they
  # exist.

  NoUpdate $(<) ;

  # Don't create . or any directory already created.

  if $(<:G=) != $(DOT) && ! $($(<)-mkdir)
  {
	# Cheesy gate to prevent multiple invocations on same dir
	# Arrange for jam dirs
	# MkDir1 has the actions

	$(<)-mkdir = true ;
	Depends dirs : $(<) ;
	MkDir1 $(<) ;

	# Recursively make parent directories.
	# $(<:P) = $(<)'s parent, & we recurse until root

	local s = $(<:P) ;

	# Don't try to create A: or A:\ on windows

	if $(NT)
	{
	  switch $(s)
	  {
		case *:   : s = ;
		case *:\\ : s = ;
	  }
	}

	# handle "C:", "C:/", "/cygdrive" and "/cygdrive/" in Cygwin
	if $(UNIX) && $(OS) = CYGWIN
	{
	  switch $(s)
	  {
		case ?:   : s = ;
		case ?:/  : s = ;
		case <dir>/cygdrive   : s = ;
		case <dir>/cygdrive/  : s = ;
	  }
	}

	if $(s) = $(<)
	{
	  # The parent is the same as the dir.
	  # We're at the root, which some OS's can't stat, so we mark
	  # it as NotFile.

	  NotFile $(s) ;
	}
	else if $(s:G=)
	{
	  # There's a parent; recurse.

	  Depends $(<) : $(s) ;
	  MkDir $(s) ;
	}
  }
}

# /Object object : source ;
#
# Compile s a single _source_ file into _object_. The @Main and @Library
# rules use it to compile sources.
#
# Causes _source_ to be scanned for #include directives and calls @HdrRule
# to make all included files dependencies of _object_.
#
# Calls one of the following rules depending on the suffix to do the
# actual compilation:
#
rule Object
{
  # locate object and search for source, if wanted
  Clean clean : $(<) ;

  MakeLocate $(<) : $(LOCATE_TARGET) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;

  # Save HDRS for -I$(HDRS) on compile.
  # We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
  # in the .c file's directory, but generated .c files (from
  # yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
  # different from $(SEARCH_SOURCE).

  HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;

  # handle #includes for source: Jam scans for headers with
  # the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
  # with the scanned file as the target and the found headers
  # as the sources.  HDRSEARCH is the value of SEARCH used for
  # the found header files.  Finally, if jam must deal with
  # header files of the same name in different directories,
  # they can be distinguished with HDRGRIST.

  # $(SEARCH_SOURCE:E) is where cc first looks for #include
  # "foo.h" files.  If the source file is in a distant directory,
  # look there.  Else, look in "" (the current directory).

  HDRRULE on $(>) = HdrRule ;
  HDRSCAN on $(>) = $(HDRPATTERN) ;
  HDRSEARCH on $(>) =
  $(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;

  HDRGRIST on $(>) = $(HDRGRIST) ;

  # propagate target specific-defines

  DEFINES on $(<) += $(DEFINES) ;

  # if source is not .c, generate .c with specific rule
  switch $(>:S)
  {
    case .h   : if $(CAN_LINT) { LintH lint_h : $(>) ; }
    case .hpp : if $(CAN_LINT) { LintH lint_h : $(>) ; }
    case .asm : Yasm $(<) : $(>) ;
    case .masm : Masm $(<) : $(>) ;
    case .c :   Cc $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
    case .m :   Cc $(<) : $(>) ;
    case .C :   C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
    case .cc :  C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
    case .cpp : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
    case .cxx : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
    case .c++ : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
    case .C++ : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
    case .mm  : C++ $(<) : $(>) ;
    case .d :   Dc $(<) : $(>) ;
    case .erl : Erl $(<:S=$(SUFBEAM)) : $(>) ;
    case .f :   Fortran $(<) : $(>) ;
    case .l :   Cc $(<) : $(<:S=.c) ;
      Lex $(<:S=.c) : $(>) ;
    case .s :   As $(<) : $(>) ;
    case .y :   Cc $(<) : $(<:S=$(YACCGEN)) ;
      Yacc $(<:S=$(YACCGEN)) : $(>) ;
    case .rc :  ResourceCompiler $(<) : $(>) ;
    case .acc : Acc $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
    case .aq :  AqCompiler $(<:S=$(SUFAQO)) : $(>) ;
    case .aqw :  AqCompiler $(<:S=$(SUFAQO)) : $(>) ;
    case .aqp :  AqCompiler $(<:S=$(SUFAQO)) : $(>) ;
    case * :    UserObject $(<) : $(>) ;
  }
}

# /ObjectOptimFlags  sources : flags ;
#
# this rule is used to add flags to the optim compilation of
# specific sources files.
#
rule ObjectOptimFlags
{
  OPTIM on [ FGristFiles $(<:S=$(SUFOBJ)) ] ?= $(OPTIM) ;
  OPTIM on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectCcFlags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific C sources files.
#
rule ObjectCcFlags
{
  CCFLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectC++Flags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific C++ source files
#
rule ObjectC++Flags
{
  C++FLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectCC++Flags sources : flags ;
rule ObjectCC++Flags
{
  ObjectCcFlags $(<) : $(>) ;
  ObjectC++Flags $(<) : $(>) ;
}

# /ObjectErlOptim  sources : flags ;
#
# this rule is used to add compiler optimization flags to the compilation of
# specific Erlang sources files.
#
rule ObjectErlOptim
{
  ERLOPTIM on [ FGristFiles $(<:S=$(SUFBEAM)) ] += $(>) ;
}

# /ObjectErlFlags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific Erlang sources files.
#
rule ObjectErlFlags
{
  ERLFLAGS on [ FGristFiles $(<:S=$(SUFBEAM)) ] += $(>) ;
}

# /ObjectErlPath  sources : paths ;
#
# this rule is used to add code paths to the compilation of
# specific Erlang source files
#
rule ObjectErlPath
{
  local s = [ FGristFiles $(<:S=$(SUFBEAM)) ] ;
  ERLPATH on $(s) += $(>) ;
}

# /ObjectErlHdrs  sources : paths ;
#
# this rule is used to add include paths to the compilation of
# specific Erlang source files
#
rule ObjectErlHdrs
{
  local s = [ FGristFiles $(<:S=$(SUFBEAM)) ] ;
  ERLHDRS on $(s) += $(>) ;
}

# /ObjectDefines  objects : macros ;
#
# this rule is used to add macro defines to the compilation of
# specific C and C++ source files
#
rule ObjectDefines
{
  # must reformat CCDEFS according to current defines

  local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;

  DEFINES on $(s) ?= $(DEFINES) ;
  CCDEFS on $(s) ?= $(CCDEFS) ;
  DEFINES on $(s) += $(>) ;
  CCDEFS on $(s) += [ on $(s) FDefines $(DEFINES) ] ;
}

# /ObjectHdrs  sources : paths ;
#
# this rule is used to add include paths to the compilation of
# specific C and C++ source files
#
rule ObjectHdrs
{
  # Add to HDRS for HdrScan's benefit.
  # must reformat CCHDRS according to headers

  local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;

  HDRS on $(s) += $(>) ;
  CCHDRS on $(s) = [ on $(s) FIncludes $(HDRS) ] ;
}

# Return the suffix of the specified source file
rule FTargetSuffix
{
  switch $(<:S) {
	case .java : return $(SUFJAVAC) ;
	case .scala : return $(SUFJAVAC) ;
	case .erl :	return $(SUFBEAM) ;
	case .aq : return $(SUFAQO) ;
	case .aqw :	return $(SUFAQO) ;
	case .aqp :	return $(SUFAQO) ;
    case .asm : return $(SUFOBJ) ;
    case .masm : return $(SUFOBJ) ;
    case .c : return $(SUFOBJ) ;
    case .m : return $(SUFOBJ) ;
    case .C : return $(SUFOBJ) ;
    case .cc : return $(SUFOBJ) ;
    case .cpp : return $(SUFOBJ) ;
    case .cxx : return $(SUFOBJ) ;
    case .c++ : return $(SUFOBJ) ;
    case .C++ : return $(SUFOBJ) ;
    case .mm  : return $(SUFOBJ) ;
    case .d : return $(SUFOBJ) ;
    case .f : return $(SUFOBJ) ;
    case .s : return $(SUFOBJ) ;
    case .rc : return $(SUFOBJ) ;
    case .acc : return $(SUFOBJ) ;
  }
  return $(<:S) ;
}

rule FTarget
{
  local s = [ FTargetSuffix $(<) ] ;
  return $(<:S=$(s)) ;
}

# ObjectSuf SOURCE
# call the Object rule with the appropriate suffix, returns the name
# of the target
rule ObjectSuf
{
  local suf = [ FTargetSuffix $(<) ] ;
  local d = $(<:S=$(suf)) ;
  switch $(suf) {
	case .class :
	  Object $(d) : $(_i) ;
	  Depends class : $(d) ;
	case .beam :
	  Object $(d) : $(_i) ;
	  Depends beam : $(d) ;
	case $(SUFAQO) :
	  Object $(d) : $(_i) ;
	  Depends aqo : $(d) ;
	case * :
	  Object $(d) : $(_i) ;
	  Depends obj : $(d) ;
  }
  return $(d) ;
}

# /Objects sources ;
#
# this rule is used to compile one or more sources into object files.
# do not call it directly, it is used by the Main and Library rules
# automatically
#
rule Objects
{
  local _i ;
  local r ;

  for _i in [ FGristFiles $(<) ]
  {
	r += [ ObjectSuf $(_i) ] ;
  }

  return $(r) ;
}

# /SharedObjects
#
# this rule is used to compile one or more sources into 'shared object
# files'. This means object files used to build either DLLs or Unix shared
# libraries.
#
# do not call this rule directly, it is called by SharedLibrary automatically
#
rule SharedObjects
{
  # temporarily override SUFOBJ with $(SUFDLLOBJ) to
  #
  local SUFOBJ = $(SUFDLLOBJ) ;

  # call the normal Objects rule
  #
  Objects $(<) ;

  if $(OS) = LINUX
  {
  }
  else if $(UNIX)
  {
	# change the compiler invokation for all these objects
	# to use Libtool on Unix systems. We explicitely disable the
	# generation of static objects here
	#
    libtool on $(<:S=$(SUFOBJ)) = [ LibToolFind ] ;
    CC on $(<:S=$(SUFOBJ))      = "$(libtool) --mode=compile $(CC) -dynamic" ;
  }
}


rule RmTemps
{
  Temporary $(>) ;
}

rule Setuid
{
  MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;
}

rule Shell
{
  Depends shell : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(SHELLMODE) ;
  Clean clean : $(<) ;
  Chmod $(<) ;
}

rule SoftLink
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  Clean clean : $(<) ;
}

rule SubDir
{
  #
  # SubDir TOP d1 d2 ... ;
  #
  # Support for a project tree spanning multiple directories.
  #
  # SubDir declares a Jamfile's location in a project tree, setting
  # Jambase variables (SEARCH_SOURCE, LOCATE_TARGET) so that source
  # files can be found.
  #
  # TOP is a user-select variable name for root of the tree, and
  # d1 d2 ...  are the directory elements that lead from the root
  # of the tree to the directory of the Jamfile.
  #
  # TOP can be set externally, but normally the first SubDir call
  # computes TOP as the path up from the current directory; the
  # path contains one ../ for each of d1 d2 ...
  #
  # SubDir reads once the project-specific rules file Jamrules
  # in the TOP directory, if present.  This can be overridden
  # with the variable TOPRULES.
  #
  # SubDir supports multiple, overlaid project trees:  SubDir
  # invocations with different TOPs can appear in the same Jamfile.
  # The location established by the first SubDir call is used set
  # the TOPs for the subsequent SubDir calls.
  #
  # SubDir's public variables:
  #
  #   $(TOP) = path from CWD to root.
  #   $(SUBDIR) = path from CWD to the directory SubDir names.
  #   $(SUBDIR_TOKENS) = path from $(TOP) to $(SUBDIR) as dir names
  #   $(SEARCH_SOURCE) = $(SUBDIR)
  #   $(LOCATE_SOURCE) = $(ALL_LOCATE_TARGET) $(SUBDIR)
  #   $(LOCATE_TARGET) = $(ALL_LOCATE_TARGET) $(SUBDIR)
  #   $(SOURCE_GRIST) = $(SUBDIR_TOKENS) with !'s
  #

  local _top = $(<[1]) ;
  local _tokens = $(<[2-]) ;

  #
  # First time through sets up relative root and includes Jamrules.
  #

  if ! $(_top)
  {
	Exit SubDir syntax error ;
  }

  if ! $($(_top)-SET)
  {
	$(_top)-SET = true ;

	# First time we've seen this TOP.
	# We'll initialize a number of internal variables:
	#
	#   $(TOP-UP) = directories from ROOT to a common point
	#   $(TOP-DOWN) = directories from common point to TOP
	#   $(TOP-ROOT) = root directory for UP/DOWN -- normally CWD
	#   $(SUBDIR_UP) = current value of $(TOP-UP)
	#   $(SUBDIR_DOWN) = current value of $(TOP-DOWN)
	#   $(SUBDIR_ROOT) = current value of $(TOP-ROOT)
	#

	if $($(_top))
	{
	  # TOP externally set.
	  # We'll ignore the relative (UP/DOWN) path that
	  # got us here, and instead remember the hard ROOT.

	  $(_top)-UP = ;
	  $(_top)-DOWN = ;
	  $(_top)-ROOT = $($(_top)) ;
	}
	else
    {
	  # TOP not preset.

	  # Establishing a new TOP.  In the simplest case,
	  # (SUBDIR_UP/SUBDIR_DOWN/SUBDIR_ROOT unset), it's
	  # merely a certain number of directories down from
	  # the current directory, and FSubDirPath will set
	  # TOP to a path consisting of ../ for each of the
	  # elements of _tokens, because that represents how
	  # far below TOP the current directory sits.
	  #
	  # In the more complicated case, the starting directory
	  # isn't the directory of jam's invocation but an
	  # location established by previous SubDir call.  The
	  # starting directory is SUBDIR_UP directories up from
	  # SUBDIR_ROOT, and then SUBDIR_DOWN directories down
	  # from that.   If SUBDIR_ROOT is not set, that means
	  # SUBDIR_DOWN and SUBDIR_UP represent the path from
	  # the directory of jam's invocation.
	  #
	  # In the most complicated case, the _tokens also
	  # represents directories down, because TOP is being
	  # estalished in a directory other than TOP's root.
	  # Hopefully, _tokens and SUBDIR_DOWN represent the
	  # same final directory, relative to the new TOP and
	  # the previous SubDIr's TOP.  To find the new TOP,
	  # we have to chop off any common directories from
	  # then ends of _tokens and SUBDIR_DOWN.  To do so,
	  # we reverse each of them, call FStripCommon to
	  # remove the initial common elements, and then
	  # reverse them again.  After this process, if
	  # both _tokens and SUBDIR_DOWN have elements, it
	  # means the directory names estalished by the two
	  # SubDir calls don't match, and a warning is issued.
	  # All hell will likely break loose at this point,
	  # since the whole SubDir scheme relies on the SubDir
	  # calls accurately naming the current directory.

	  # Strip common trailing elements of _tokens and SUBDIR_DOWN.

	  _tokens = [ FReverse $(_tokens) ] ;
	  SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
	  FStripCommon _tokens : SUBDIR_DOWN ;
	  SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
	  _tokens = [ FReverse $(_tokens) ] ;

	  if $(SUBDIR_DOWN) && $(_tokens)
	  {
		Echo Warning: SubDir $(<) misplaced! ;
	  }

	  # We'll remember the relative (UP/DOWN) path that
	  # got us here, plus any hard ROOT starting point
	  # for the UP/DOWN.  If TOP is never set externally,
	  # ROOT will always be "" (directory of jam's invocation).

	  $(_top)-UP = $(SUBDIR_UP) $(_tokens) ;
	  $(_top)-DOWN = $(SUBDIR_DOWN) ;
	  $(_top)-ROOT = $(SUBDIR_ROOT:E="") ;
	  $(_top) = [ FSubDirPath $(_top) ] ;
	}

	# Set subdir vars for the inclusion of the Jamrules,
	# just in case they have SubDir rules of their own.
	# Note that SUBDIR_DOWN is empty: it's all the way
	# up where the Jamrules live.  These gets overrided
	# just after the inclusion.

	SUBDIR_UP = $($(_top)-UP) ;
	SUBDIR_DOWN = ;
	SUBDIR_ROOT = $($(_top)-ROOT) ;

	# Include $(TOPRULES) or $(TOP)/Jamrules.
	# Include $(TOPRULES) if set.
	# Otherwise include $(TOP)/Jamrules if present.

	if $($(_top)RULES) {
	  include $($(_top)RULES) ;
	  } else {
		NoCare $(JAMRULES:R=$($(_top)):G=$(_top)) ;
		include $(JAMRULES:R=$($(_top)):G=$(_top)) ;
	  }
  }

  # Get path from $(TOP) to named directory.
  # Save dir tokens for other potential uses.

  SUBDIR_UP = $($(_top)-UP) ;
  SUBDIR_DOWN = $($(_top)-DOWN) $(_tokens) ;
  SUBDIR_ROOT = $($(_top)-ROOT) ;
  SUBDIR_TOKENS = $(SUBDIR_DOWN) ;

  SUBDIR = [ FSubDirPath $(<) ] ;

  # Now set up SEARCH_SOURCE, LOCATE_TARGET, SOURCE_GRIST
  # These can be reset if needed.  For example, if the source
  # directory should not hold object files, LOCATE_TARGET can
  # subsequently be redefined.

  SEARCH_SOURCE = $(SUBDIR) ;
  LOCATE_SOURCE = $(ALL_LOCATE_TARGET) $(SUBDIR) ;
  LOCATE_TARGET = $(ALL_LOCATE_TARGET) $(SUBDIR) ;
  SOURCE_GRIST = [ FGrist $(SUBDIR_TOKENS) ] ;

  # Reset per-directory ccflags, hdrs, etc,
  # listed in SUBDIRRESET.
  # Note use of variable expanded assignment var

  SUBDIR$(SUBDIRRESET) = ;

  # Invoke user-specific SubDir extensions,
  # rule names listed in SUBDIRRULES.
  # Note use of variable expanded rule invocation

  $(SUBDIRRULES) $(<) ;
}

rule FSubDirPath
{
  # FSubDirPath TOP d1 ... ;

  # Returns path to named directory.

  # If jam is invoked in a subdirectory of the TOP, then we
  # need to prepend a ../ for every level we must climb up
  # (TOP-UP), and then append the directory names we must
  # climb down (TOP-DOWN), plus the named directories d1 ...
  # If TOP was set externally, or computed from another TOP
  # that was, we'll have to reroot the whole thing at TOP-ROOT.

  local _r = [ FRelPath $($(<[1])-UP) : $($(<[1])-DOWN) $(<[2-]) ] ;

  return $(_r:R=$($(<[1])-ROOT)) ;
}

rule SubDirDcFlags
{
  SUBDIRDCFLAGS += $(<) ;
}

rule SubDirErlFlags
{
  SUBDIRERLFLAGS += $(<) ;
}

rule SubDirCcFlags
{
  SUBDIRCCFLAGS += $(<) ;
}

rule SubDirC++Flags
{
  SUBDIRC++FLAGS += $(<) ;
}

rule SubDirCC++Flags
{
  SubDirCcFlags $(<) ;
  SubDirC++Flags $(<) ;
}

rule SubDirHdrs
{
  SUBDIRHDRS += [ FDirName $(<) ] ;
  ERLHDRS += [ FDirName $(<)/include ] ;
}

rule SubInclude
{
  # SubInclude TOP d1 ... ;
  #
  # Include a subdirectory's Jamfile.

  # We use SubDir to get there, in case the included Jamfile
  # either doesn't have its own SubDir (naughty) or is a subtree
  # with its own TOP.

  if ! $($(<[1]))
  {
	Exit SubInclude $(<[1]) without prior SubDir $(<[1]) ;
  }

  SubDir $(<) ;

  include $(JAMFILE:D=$(SUBDIR)) ;
}

rule SubRules
{
  # SubRules TOP d1 ... : Other-TOP ;
  #
  # Read another tree's Jamrules, by giving it's path according
  # to this tree and it's own name.

  if ! $($(<[1]))
  {
	Exit SubRules $(<[1]) without prior SubDir $(<[1]) ;
  }

  SubDir $(<) ;
  SubDir $(>) ;
}

rule Undefines
{
  UNDEFS on [ FAppendSuffix $(<) : $(SUFEXE) ] += $(UNDEFFLAG)$(>) ;
}

rule UserObject
{
  Exit "Unknown suffix on" $(>) "- see UserObject rule in Jamfile(5)." ;
}

rule Yacc
{
  local _h ;

  _h = $(<:BS=.h) ;

  # Some places don't have a yacc.

  MakeLocate $(<) $(_h) : $(LOCATE_SOURCE) ;

  if $(YACC)
  {
	Depends $(<) $(_h) : $(>) ;
	Yacc1 $(<) $(_h) : $(>) ;
	YaccMv $(<) $(_h) : $(>) ;
	Clean clean : $(<) $(_h) ;
  }

  # make sure someone includes $(_h) else it will be
  # a deadly independent target

  Includes $(<) : $(_h) ;
}

# aglCPP compiler
rule Acc
{
  local _h ;
  _h = [ FDirName $(SUBDIR) $(>:BS=.acc.hpp) ] ;
  local _cpp ;
  _cpp = [ FDirName $(SUBDIR) $(>:BS=.acc.cxx) ] ;

  Depends $(_cpp) $(_h) : $(>) ;
  Includes $(_cpp) : $(_h) ;
  C++ $(<) : $(_cpp) ;

  RmTemps $(<) : $(_h) $(_cpp) ;
}
actions Acc
{
  aglCPP -e $(>)
}

#
# Utility rules; no side effects on these
#

# /FGrist path to file ;
#
# Returns a single string that is used as grist
#
rule FGrist
{
  return $(<:J=!) ;

}


rule FGristFiles
{
  return $(<:G=$(SOURCE_GRIST:E)) ;
}


rule FGristSourceFiles
{
  # Produce source file name name with grist in it,
  # if SOURCE_GRIST is set.

  # Leave header files alone, because they have a global
  # visibility.

  if ! $(SOURCE_GRIST)
  {
	return $(<) ;
  }
  else
  {
	local _i _o ;

	for _i in $(<)
	{
	  switch $(_i)
	  {
        case *.h :  _o += $(_i) ;
        case * :    _o += $(_i:G=$(SOURCE_GRIST)) ;
	  }
	}

	return $(_o) ;
  }
}


rule FReverse
{
  if $(1) { return [ FReverse $(1[2-]) ] $(1[1]) ; }
}


rule FSubDir
{
  # If $(>) is the path to the current directory, compute the
  # path (using ../../ etc) back to that root directory.
  # Sets result in $(<)

  if ! $(<[1])
  {
	return $(DOT) ;
  }
  else
  {
	local _i _d ;

	_d = $(DOTDOT) ;

	for _i in $(<[2-])
	{
	  _d = $(_d:R=$(DOTDOT)) ;
	}

	return $(_d) ;
  }
}


rule FStripCommon
{
  # FStripCommon v1 : v2 ;

  # Strip common initial elements of variables v1 and v2.
  # Modifies the variable values themselves.

  if $($(<)[1]) && $($(<)[1]) = $($(>)[1])
  {
	$(<) = $($(<)[2-]) ;
	$(>) = $($(>)[2-]) ;
	FStripCommon $(<) : $(>) ;
  }
}


rule FRelPath
{
  local _l _r ;

  # first strip off common parts

  _l = $(<) ;
  _r = $(>) ;

  FStripCommon _l : _r ;

  # now make path to root and path down

  _l = [ FSubDir $(_l) ] ;
  _r = [ FDirName $(_r) ] ;

  # Concatenate and save

  # XXX This should be better

  if $(_r) = $(DOT) {
	return $(_l) ;
    } else {
	  return $(_r:R=$(_l)) ;
    }
}


rule FAppendSuffix
{
  # E.g., "FAppendSuffix yacc lex foo.bat : $(SUFEXE) ;"
  # returns (yacc,lex,foo.bat) on Unix and
  # (yacc.exe,lex.exe,foo.bat) on NT.

  if $(>)
  {
	local _i _o ;

	for _i in $(<)
	{
	  if $(_i:S)
	  {
		_o += $(_i) ;
	  }
	  else
	  {
		_o += $(_i:S=$(>)) ;
	  }
	}
	return $(_o) ;
  }
  else
  {
	return $(<) ;
  }
}

#
# Operating system specific utility rules
# First, the (generic) UNIX versions
#

rule FDefinesDash { return -D$(<) ; }
rule FIncludesDash { return -I$(<) ; }
rule FDefinesSlash { return /D$(<) ; }
rule FIncludesSlash { return /I$(<) ; }

rule FQuote {
  if $(<) {
    return "\"$(<)\"" ;
  }
  else {
    return "\"\"" ;
  }
}

rule FDefines { return -D$(<) ; }
rule FIncludes { return -I$(<) ; }
rule FIncludesLint { return -i$(<) ; }

rule FDirName
{
  # Turn individual elements in $(<) into a usable path.

  local _i ;
  local _s = $(DOT) ;

  for _i in $(<)
  {
	_s = $(_i:R=$(_s)) ;
  }

  return $(_s) ;
}

rule FGristDirName
{
  return [ FGristFiles [ FDirName $(<) ] ] ;
}

# Remove all .. and . from a list to create a "clean" list that can be used to build absolute path
rule FCleanDirs {
  local r = ;
  local prevprev = ;
  local prev = ;
  for _d in $(<) {
    if $(_d) = $(DOTDOT) {
      r = $(prev) ;
    }
    else if $(_d) = $(DOT) {
    }
    else {
      prev = $(r) ;
      r += $(_d) ;
    }
  }
  return $(r) ;
}

# Return an absolute directory path from a path which is relative to the SUBDIR
rule FSubDirAbsName {
  if ! $(TOP_DIR) {
    EXIT "The TOP_DIR environment variable must be set in your local _rules.ham." ;
  }

  local d = [ FCleanDirs $(SUBDIR_TOKENS) $(<) ] ;
  return [ FDirName $(TOP_DIR) $(d) ] ;
}

if $(OS2)
{
  rule FQuote { return "\"$(<)\"" ; }
  rule FIncludes { return /I$(<) ; }
}
# else if $(NT) && $(HAM_TOOLSET) != MINGW
# {
#   rule FDefines { return /D$(<) ; }
#   rule FIncludes { return /I$(<) ; }
# }

else if $(MAC)
{
  rule FQuote { return "\"$(<)\"" ; }
  rule FDefines { return "-define '$(<)'" ; }
  rule FIncludes { return "\"$(<:J=,)\"" ; }
}

else if $(VMS)
{
  rule FQuote { return "\"\"\"$(<)\"\"\"" ; }
  rule FDefines { return "/define=( $(<:J=,) )" ; }
  rule FIncludes { return "/inc=( $(<:J=,) )" ; }

  rule FDirName
  {
	local _s _i ;

	# Turn individual elements in $(<) into a usable path.

	if ! $(<)
	{
	  _s = $(DOT) ;
	}
	else
	{
	  # This handles the following cases:
	  #   a -> [.a]
	  #   a b c -> [.a.b.c]
	  #   x: -> x:
	  #   x: a -> x:[a]
	  #   x:[a] b -> x:[a.b]

	  switch $(<[1])
	  {
		case *:* :     _s = $(<[1]) ;
		case \\[*\\] : _s = $(<[1]) ;
		case * :       _s = [.$(<[1])] ;
	  }

	  for _i in [.$(<[2-])]
	  {
		_s = $(_i:R=$(_s)) ;
	  }
	}

	return $(_s) ;
  }
}

#
# Actions
#

#
# First the defaults
#

actions updated together piecemeal Archive
{
  $(AR) $(<) $(>)
}

actions As
{
  $(AS) $(ASFLAGS) $(ASHDRS) -o $(<) $(>)
}

actions Yasm
{
  $(YASM) $(YASMFLAGS) $(YASMHDRS) $(YASMDEFS) -o $(<) $(>)
}

actions Masm
{
  ml -nologo -Fo $(<) -c $(>)
}

actions C++
{
  $(C++) -c -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
}

actions Cc
{
  $(CC) -c -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
}

rule LintC
{
  Depends $(<) : $(>) ;
  Depends lint : $(<) ;
  LINT_HDRS on $(<) = [ on $(<) FIncludesLint $(HDRS) ] ;
}
actions LintC
{
  $(LINT_C) $(LINT_HDRS) $(>) ; $(LINT_CANNOT_FAIL)
}

rule LintH
{
  Depends $(<) : $(>) ;
  Depends lint : $(<) ;
  LINT_HDRS on $(<) = [ on $(<) FIncludesLint $(HDRS) ] ;
}
actions LintH
{
  $(LINT_H) $(LINT_HDRS) $(>) ; $(LINT_CANNOT_FAIL)
}

actions Dc
{
  $(DC) -c -of$(<) $(DCFLAGS) $(DOPTIM) $(>)
}

actions Erl
{
  $(ERLC) $(ERLFLAGS) $(ERLOPTIM) $(ERLHDRS) -D$(ERLDEFS) -pa$(ERLPATH) -o$(<:D) $(>)
}

actions Chgrp
{
  $(CHGRP) $(GROUP) $(<)
}

actions Chmod1
{
  $(CHMOD) $(MODE) $(<)
}

actions Chown
{
  $(CHOWN) $(OWNER) $(<)
}

actions piecemeal together existing Clean
{
  $(RM) $(>)
}

actions Cp
{
  $(CP) $(>) $(<)
}

actions File
{
  $(CP) $(>) $(<)
}

actions FilePreserve
{
  $(CP_PRESERVE) $(>) $(<)
}

actions GenFile1
{
  $(>[1]) $(<) $(>[2-])
}

actions Fortran
{
  $(FORTRAN) $(FORTRANFLAGS) -o $(<) $(>)
}

actions HardLink
{
  $(RM) $(<) && $(LN) $(>) $(<)
}

actions Lex
{
  $(LEX) $(>)
}

actions LexMv
{
  $(MV) lex.yy.c $(<)
}

actions Link bind NEEDLIBS
{
  $(LINK) $(LINKFLAGS) -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
}

if $(OS) = MACOSX {
  actions DllLink bind NEEDLIBS
  {
    $(LINK) $(LINKFLAGS) -dynamiclib -fPIC -fvisibility=hidden -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
  }
}
else {
  actions DllLink bind NEEDLIBS
  {
    $(LINK) $(LINKFLAGS) -fvisibility=hidden -shared -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
  }
}

actions MkDir1
{
  $(MKDIR) $(<)
}

actions together Ranlib
{
  $(RANLIB) $(<)
}

actions quietly updated piecemeal together RmTemps
{
  $(RM) $(>)
}

actions Shell
{
  $(AWK) '
  NR == 1 { print "$(SHELLHEADER)" }
  NR == 1 && /^[#:]/ { next }
  /^##/ { next }
  { print }
  ' < $(>) > $(<)
}

actions SoftLink
{
  $(RM) $(<) && $(LN) -s $(>) $(<)
}

actions Yacc1
{
  $(YACC) $(YACCFLAGS) $(>)
}

actions YaccMv
{
  $(MV) $(YACCFILES).c $(<[1])
  $(MV) $(YACCFILES).h $(<[2])
}

#
# RELOCATE - for compilers with broken -o flags
#

if $(RELOCATE)
{
  actions C++
  {
	$(C++) -c $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
  }

  actions Cc
  {
	$(CC) -c $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
  }

  actions ignore CcMv
  {
	[ $(<) != $(>:BS=$(SUFOBJ)) ] && $(MV) $(>:BS=$(SUFOBJ)) $(<)
  }
}

#
# NOARUPDATE - can't update an archive
#

if $(NOARUPDATE)
{
  actions Archive
  {
	$(AR) $(<) $(>)
  }
}

#
# UNIX specific actions
#

if $(UNIX)
{
  actions GenFile1
  {
    PATH="$PATH:."
    $(>[1]) $(<) $(>[2-])
  }
}

if $(ANDROID)
{
  ADR_LIBS  = [ FDirName $(ADRDIR) adds/lib/a16 ] ;

  actions together piecemeal Archive
  {
    $(AR) $(<) $(>:T)
  }

  actions Cc
  {
    $(CC) -c -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) $(>)
  }

  actions C++
  {
    $(C++) -c -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) $(>)
  }

  #     actions Link bind NEEDLIBS
  #     {
    #       $(LINK) --entry=_start -Bsymbolic --no-undefined --dynamic-linker //system/bin/linker -nostdlib -rpath //system/lib -rpath $(ADR_LIBS) -L $(ADR_LIBS) -o $(<) $(UNDEFS) $(>) $(NEEDLIBS) -lm -lc -lstdc++ -lui $(LINKLIBS)
  #     }

  actions Link bind NEEDLIBS
  {
    $(LINK) $(LINKFLAGS) $(ANDROID_LINK_EXE_ARGS) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS) -o $(<)
  }
  actions DllLink bind IMPLIBNAME
  {
    $(LINK) $(LINKFLAGS) $(ANDROID_LINK_DLL_ARGS) $(>) $(LINKLIBS) $(SYSTEM_LINKLIBS) -o $(<)
  }
}

#
# NT specific actions
#

else if $(NT)
{
  actions ResourceCompiler
  {
	rc -fo $(<) $(CCHDRS) $(RCFLAGS) $(>)
  }

  if $(JSCC_EMU) = VC10 ||  $(HAM_TOOLSET) = VISUALC || $(HAM_TOOLSET) = INTELC
  {
    actions Archive
	{
	  $(AR) -NOLOGO -WX:NO -out:$(<) $(>)
	}

    if $(CC_ISCLANG) = 1 {
      actions Cc
      {
        $(CC) -c -o $(<) $(CCFLAGS) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) -I$(AGLDEVENV)/vc9/include $(>)
      }
      actions Link bind NEEDLIBS
      {
        $(LINK) -FORCE -ignore:4006 $(LINKFLAGS) -DEBUG -out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
      }

      actions DllLink bind NEEDLIBS IMPLIBNAME
      {
        $(LINK) -FORCE -ignore:4006 $(LINKFLAGS) -DLL -IMPLIB:$(IMPLIBNAME) -DEBUG -out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
      }
    }
    else {
      actions Cc
      {
        $(CC) -c -Fo$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) -Tc$(>)
      }
      actions Link bind NEEDLIBS
      {
        $(LINK) $(LINKFLAGS) -DEBUG -out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
      }
      actions DllLink bind NEEDLIBS IMPLIBNAME
      {
        $(LINK) $(LINKFLAGS) -DLL -IMPLIB:$(IMPLIBNAME) -DEBUG -out:$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
      }
    }

	actions C++
	{
	  $(C++) -c -Fo$(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) -Tp$(>)
	}
  }
  else if $(HAM_TOOLSET) = MINGW
  {
	actions together piecemeal Archive
	{
	  $(AR) $(<) $(>:T)
	}

	actions Cc
	{
	  $(CC) -c -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) $(>)
	}

	actions C++
	{
	  $(C++) -c -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -I$(STDHDRS) $(>)
	}

	actions DllLink bind IMPLIBNAME
	{
	  $(LINK) $(LINKFLAGS) -shared -o $(<) $(>) -Wl,--out-implib,$(IMPLIBNAME) $(LINKLIBS) $(SYSTEM_LINKLIBS)
	}
  }
  else if $(HAM_TOOLSET) = DIGITALMARS
  {
	actions together piecemeal Archive
	{
	  $(AR) $(<) $(>)
	}

	actions Cc
	{
	  $(CC) -c $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -o$(<) -I$(STDHDRS) $(>)
	}

	actions C++
	{
	  $(C++) -c $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) -o$(<) -I$(STDHDRS) $(>)
	}

	# note: we don't generate MAP files here !
	actions Link bind NEEDLIBS
	{
	  $(LINK) $(LINKFLAGS) $(>),$(<),NUL, $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
	}

	# note: we don't generate MAP files here !
	actions DllLink bind NEEDLIBS IMPLIBNAME
	{
	  $(LINK) $(LINKFLAGS) /IMPLIB:$(IMPLIBNAME) $(>) , $(<) ,NUL, $(LINKLIBS:E) $(NEEDLIBS:E)
	}

	actions Shell
	{
	  $(CP) $(>) $(<)
	}
  }
}

#
# OS2 specific actions
#

else if $(OS2)
{
  if $(HAM_TOOLSET) = WATCOM
  {
	actions together piecemeal Archive
	{
	  $(AR) -q $(<) +-$(>)
	}

	actions Cc
	{
	  $(CC) /Fo=$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
	}

	actions C++
	{
	  $(C++) /Fo=$(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
	}

	actions Link bind NEEDLIBS
	{
	  $(LINK) -q $(LINKFLAGS) /Fe=$(<) $(UNDEFS) $(>) $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
	}

	actions Shell
	{
	  $(CP) $(>) $(<)
	}
  }
  else if $(HAM_TOOLSET) = EMX
  {
	actions together piecemeal Archive
	{
	  $(AR) $(<) $(>:T)
	}

	actions Cc
	{
	  $(CC) -c -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
	}

	actions C++
	{
	  $(C++) -c -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
	}
  }
}

#
# VMS specific actions
#

else if $(VMS)
{
  actions updated together piecemeal Archive
  {
	lib/replace $(<) $(>[1]) ,$(>[2-])
  }

  actions Cc
  {
	$(CC)/obj=$(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
  }

  actions C++
  {
	$(C++)/obj=$(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) $(>)
  }

  actions piecemeal together existing Clean
  {
	$(RM) $(>[1]);* ,$(>[2-]);*
  }

  actions together quietly CreLib
  {
	if f$search("$(<)") .eqs. "" then lib/create $(<)
  }

  actions GenFile1
  {
	mcr $(>[1]) $(<) $(>[2-])
  }

  actions Link bind NEEDLIBS
  {
	$(LINK)/exe=$(<) $(LINKFLAGS) $(>:J=,) ,$(NEEDLIBS)/lib ,$(LINKLIBS) $(SYSTEM_LINKLIBS)
  }

  actions quietly updated piecemeal together RmTemps
  {
	$(RM) $(>[1]);* ,$(>[2-]);*
  }

  actions Shell
  {
	$(CP) $(>) $(<)
  }
}

#
# Mac specifc actions
#

else if $(MAC)
{
  actions together Archive
  {
	$(LINK) -library -o $(<) $(>)
  }

  actions Cc
  {
	set -e MWCincludes $(CCHDRS)
	$(CC) -o $(<) $(CCFLAGS) $(OPTIM) $(CCDEFS) $(>)
  }

  actions C++
  {
	set -e MWCincludes $(CCHDRS)
	$(CC) -o $(<) $(C++FLAGS) $(OPTIM) $(CCDEFS) $(>)
  }

  actions Link bind NEEDLIBS
  {
	$(LINK) -o $(<) $(LINKFLAGS) $(>) $(NEEDLIBS) "$(LINKLIBS)"
  }
}

if $(WIN98)
{
  actions existing Clean
  {
	del $(>)
  }
}

#
# Backwards compatibility with jam 1, where rules were uppercased.
#

rule BULK { Bulk $(<) : $(>) ; }
rule FILE { File $(<) : $(>) ; }
rule HDRRULE { HdrRule $(<) : $(>) ; }
rule LIBRARY { Library $(<) : $(>) ; }
rule LIBS { LinkLibraries $(<) : $(>) ; }
rule LINK { Link $(<) : $(>) ; }
rule MAIN { Main $(<) : $(>) ; }
rule SETUID { Setuid $(<) ; }
rule SHELL { Shell $(<) : $(>) ; }
rule UNDEFINES { Undefines $(<) : $(>) ; }

# FDirNameFiles DIR : FILES
rule FDirNameFiles {
  local t ;
  for _i in $(>) {
	t += [ FDirName $(<) $(_i) ] ;
  }
  return $(t) ;
}

# SrcSubDir PACKAGE : d1 .. dn : OBJDIR : SRC
rule SrcSubDir
{
  SubDirHdrs $(SUBDIR) $(>) ;
  MakeLocate ObjDir_$(<) : [ FDirName $(3) $(>) ] ;
  NotFile ObjDir_$(<) ;
  NoUpdate ObjDir_$(<) ;
  Depends $(<) : ObjDir_$(<) ;
  local s = [ FDirNameFiles $(>) : $(4) ] ;
  Depends [ FGristFiles $(s) ] : ObjDir_$(<) ;
  return $(s) ;
}

# SrcSubDirGlob PACKAGE : d1 .. dn : OBJDIR : SRC_PATTERN
rule SrcSubDirGlob
{
  local d = [ FDirName $(SUBDIR) $(>) ] ;
  local s = [ GlobSrc $(d) : $(4) ] ;
  return [ SrcSubDir $(<) : $(>) : $(3) : $(s) ] ;
}

# SrcSubDir PACKAGE : d1 .. dn : OBJDIR : SRC
rule SrcSubDirNoHdrs
{
  MakeLocate ObjDir_$(<) : [ FDirName $(3) $(>) ] ;
  NotFile ObjDir_$(<) ;
  NoUpdate ObjDir_$(<) ;
  Depends $(<) : ObjDir_$(<) ;
  local s = [ FDirNameFiles $(>) : $(4) ] ;
  Depends [ FGristFiles $(s) ] : ObjDir_$(<) ;
  return $(s) ;
}

# SrcSubDirGlob PACKAGE : d1 .. dn : OBJDIR : SRC_PATTERN
rule SrcSubDirGlobNoHdrs
{
  local d = [ FDirName $(SUBDIR) $(>) ] ;
  local s = [ GlobSrc $(d) : $(4) ] ;
  return [ SrcSubDirNoHdrs $(<) : $(>) : $(3) : $(s) ] ;
}

# Return source files with the given extension
# REM: Excludes files starting with an underscore or a dot,
#      they are considered hidden/auto-generated.
# EXAMPLE: GlobSrc DIR : cpp h asm ;
rule GlobSrcWithDir
{
  return [ GLOB [ FDirName $(<) ] : "[^_.]*."$(>) ] ;
}
rule GlobSrc
{
  local r ;
  local t = [ GlobSrcWithDir $(<) : $(>) ] ;
  for _i in $(t) {
	r += $(_i:B)$(_i:S) ;
  }
  return $(r) ;
}

# TargetLinkLibs TARGET : LIBS ;
rule TargetLinkLibs
{
  LINKLIBS on $(<) ?= $(LINKLIBS) ;
  LINKLIBS on $(<) += $(>) ;
}

rule ResourceCompiler
{
  DEPENDS $(<) : $(>) ;
  Clean clean : $(<) ;
}

# FileExists File
# REM: Tests only the filename not the directory path
rule FileExists
{
  local f = [ GLOB "." : $(<) ] ;
  if $(f) {  return 1 ; }
  return 0 ;
}

rule TestFileExists
{
  local d = [ FDirName $(2) ] ;
  for _i in $(3) {
	local t = $(_i:B)$(_i:S) ;
	local f = [ GLOB $(d) : $(t) ] ;
	f = $(f:B)$(f:S) ;
	if ! ( $(f) = $(t) ) {
# 	  Echo "FF: [$(f)] = [$(t)]" ;
	  Exit "Test Failed : $(1) : Can't find '$(3)' in '$(d)' !" ;
	}
  }
}


rule aglIsInList {
  for _i in $(>) {
    if ( $(_i) = $(<) ) {
      return 1 ;
    }
  }
  return 0 ;
}

# Return 1 if the element has already been include, else 0
rule aglIncludeOnce {
  if $(NO_ONCEGUARD) { return 0 ; }
  local dir = [ FDirName $(<) ] ;
  local inList = [ aglIsInList $(dir) : $(ONCE_LIST) ] ;
  if $(inList) = 1 { return 1 ; }
  return 0 ;
}

rule aglSubDirOnce {
  if [ aglIncludeOnce $(<) ] = 1 { return 1 ; }
  ONCE_LIST += [ FDirName $(<) ] ;
  SubDir $(<) ;
  return 0 ;
}

# SrcListDeps $(SRC) : $(DEPENDENCIES)
rule SrcListDeps {
  DEPENDS [ FGristFiles $(<) ] : $(>) ;
}

# ListDirs BASEDIR : PATTERN : EXCLUDE PATTERN
rule ListDirs {
  local p ;
  if $(>) {
    p = $(>) ;
  }
  else {
    p = "*" ;
  }
  local xp = "*.." "*." "*/.." "*/." ;
  if $(3) {
    xp += $(3) ;
  }

  local r = ;
  for _i in $(<) {
    local f = [ GLOB [ FDirName $(_i) ] : $(p) ] ;
    for _f in $(f) {
      if [ FISDIR $(_f) ] && ! [ GLOBSTRING $(_f) : $(xp) ] {
        r += $(_f) ;
      }
    }
  }
  return $(r) ;
}
# ListDirsR BASEDIR : PATTERN : EXCLUDE PATTERN
# Recursively list directories
rule ListDirsR {
  local r = [ ListDirs $(<) : $(>) : $(3) ] ;
  for _d in $(r) {
    r += [ ListDirsR $(_d) : $(>) : $(3) ] ;
  }
  return $(r) ;
}

# ListFiles DIRS : PATTERN : EXCLUDE PATTERN
# Recursively list directories
rule ListFiles {
  local r ;
  local p ;
  if $(>) {
    p = $(>) ;
  }
  else {
    p = "*" ;
  }
  local xp = "*.." "*." "*/.." "*/." ;
  if $(3) {
    xp += $(3) ;
  }

  for _d in $(<) {
    local f = [ GLOB [ FDirName $(_d) ] : $(p) ] ;
    for _f in $(f) {
      local fn = $(_f:B)$(_f:S) ;
      if ! [ FISDIR $(_f) ] && ! [ GLOBSTRING $(fn) : $(xp) ] {
        r += $(_f) ;
      }
    }
  }
  return $(r) ;
}

# ListContains LIST : token
# Check whether the list contains the specified token
rule ListContains {
  for _d in $(<) {
    if $(_d) = $(>) {
      return 1 ;
    }
  }
  return ;
}

# ListAddFront LIST : token
rule ListAddFront {
  return $(>) $(<) ;
}

rule ListAddFrontOnce {
  if [ ListContains $(<) : $(>) ] {
    return $(<) ;
  }
  return [ ListAddFront $(<) : $(>) ] ;
}

# ListAddBack LIST : token
rule ListAddBack {
  return $(<) $(>) ;
}

rule ListAddBackOnce {
  if [ ListContains $(<) : $(>) ] {
    return $(<) ;
  }
  return [ ListAddBack $(<) : $(>) ] ;
}

rule RunExe {
  DEPENDS $(<) : $(>) ;
  if ! $(3) {
    if $(SUBDIR) {
      WORKDIR on $(<) = $(SUBDIR) ;
    }
    else {
      WORKDIR on $(<) = . ;
    }
  }
  else {
    WORKDIR on $(<) = $(3) ;
  }
}
actions RunExe {
  cd $(WORKDIR)
  ./$(>)$(SUFEXE)
}

#
# Now include the user's Jamfile.
#

include $(JAMFILE) ;
